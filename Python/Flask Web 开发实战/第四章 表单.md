# 表单

## 4.1 背景

1. 在 Web 程序中，表单是和用户交互最常见的方式之一。用户注册、 登录、撰写文章、编辑设置，无一不用到表单。

2. 不过，表单的处理却并不简单。你不仅要创建表单，验证用户输入的内容，向用户显示错误提示，还要获取并保存数据。

3. 幸运的是，强大的 WTForms 可以帮我们解决这些问题。WTForms 是一个使用 Python 编写的表单库，它使得表单的定义、验证(服务器端)和处理变得非常轻松。这一章我们会介绍在 Web 程序中处理表单的方法和技巧。

4. 本章新涉及的 Python 包如下所示：

   - WTForms(2.2)
     - [主页](https://github.com/wtforms/wtforms)
     - [文档](https://wtforms.readthedocs.io/en/latest/)
   - Flask-WTF(0.14.2)
     - [主页](https://github.com/lepture/flask-wtf)
     - [文档](https://flask-wtf.readthedocs.io/en/latest/)
   - Flask-CKEditor(0.4.0)
     - [主页](https://github.com/greyli/flask-ckeditor)
     - [文档](https://flask-ckeditor.readthedocs.io/)

5. 本章的示例程序在 helloflask/demos/form 目录下，确保当前目录在 helloflask/demos/form 下并激活了虚拟环境，然后执行 flask run 命令运行程序：

   ```python
   cd demos/form
   flask run
   ```

## 4.2 HTML 表单

1. 在 HTML 中，表单通过 `<form>` 标签创建，表单中的字段使用 `<input>` 标签定义。下面是一个非常简单的 HTML 表单：

   ```html
   <form method="post">
       <label for="username">Username</label><br>
       <input type="text" name="username" placeholder="Héctor Rivera"><br>
       <label for="password">Password</label><br>
       <input type="password" name="password" placeholder="19001130"><br>
       <input id="remember" name="remember" type="checkbox" checked>
       <label for="remember"><small>Remember me</small></label><br>
       <input type="submit" name="submit" value="Log in">
   </form>
   ```

2. 在 HTML 表单中，我们创建 `<input>` 标签表示各种输入字段，`<label>` 标签则用来定义字段的标签文字。我们可以在 `<form>` 和 `<input>` 标签中使用各种属性来对表单进行设置。

3. 上面的表单被浏览器解析后会生成两个输入框，一个勾选框和一个提交按钮。如果你运行了示例程序，访问 <http://localhost:5000/html> 可以看到渲染后的表单

4. WTForms 支持在 Python 中使用类定义表单，然后直接通过类定义生成对应的 HTML 代码，这种方式更加方便，而且使表单更易于重用。因此，除非是非常简单的程序，或者是你想让表单的定义更加灵活，否则我们一般不会在模板中直接使用 HTML 编写表单。

## 4.3 使用 Flask-WTF 处理表单

1. 扩展 Flask-WTF 集成了 WTForms ，使用它可以在 Flask 中更方便地使用 WTForms 。

2. Flask-WTF 将表单数据解析、CSRF 保护、文件上传等功能与 Flask 集成，另外还附加了 reCAPTCHA 支持。

3. reCAPTCHA(<https://www.google.com/recaptcha/>)是 Google 开发的免费验证码服务，在国内目前无法直接使用。

4. 首先，和其他扩展一样，我们先用 Pipenv 安装 Flask-WTF 及其依赖：

   ```bash
   pipenv install flask-wtf
   ```

5. Flask-WTF 默认为每个表单启用 CSRF 保护，它会为我们自动生成和验证 CSRF 令牌。默认情况下，Flask-WTF 使用程序密钥来对 CSRF 令牌进行签名，所以我们需要为程序设置密钥：

   ```python
   app.secret_key = 'secret string'
   ```

### 4.3.1 定义 WTForms 表单类

1. 当使用 WTForms 创建表单时，表单由 Python 类表示，这个类继承从 WTForms 导入的 Form 基类。

2. 一个表单由若干个输入字段组成，这些字段分别用表单类的类属性来表示(字段即 Field，你可以简单理解为表单内的输入框、按钮等部件)。

3. 下面定义了一个 LoginForm 类，最终会生成我们在前面定义的 HTML 表单：

   ```python
   >>> from wtforms import Form, StringField, PasswordField, BooleanField, SubmitField

   >>> from wtforms.validators import DataRequired, Length

   >>> class LoginForm(Form):
   ... username = StringField('Username', validators=[DataRequired()])
   ... password = PasswordField('Password', validators=[DataRequired(), Length(8, 128)])
   ... remember = BooleanField('Remember me')
   ... submit = SubmitField('Log in')
   ```

4. 每个字段属性通过实例化 WTForms 提供的字段类表示。字段属性的名称将作为对应 HTML `<input>` 元素的 name 属性及 id 属性值。

5. 字段属性名称大小写敏感，不能以下划线或 validate 开头。

6. 这里的 LoginForm 表单类中定义了四个字段：文本字段 StringField、 密码字段 Password-Field、勾选框字段 BooleanField 和提交按钮字段 SubmitField 。字段类从 wtforms 包导入，常用的 WTForms 字段如下表所示。

7. 有些字段最终生成的 HTML 代码相同，不过 WTForms 会在表单提交 后根据表单类中字段的类型对数据进行处理，转换成对应的 Python 类型，以便在 Python 脚本中对数据进行处理。

   <center><b>常用的 WTForms 字段</b></center>

   |    字段类     |                     说明                      |           对应的 HTML 表示           |
   | :-----------: | :-------------------------------------------: | :----------------------------------: |
   | BooleanField  |      副选框，值会被处理为 True 或 False       |      `<input type='checkbox'>`       |
   |   DateField   |   文本字段，值会被处理为 datetime.date 对象   |        `<input type='text'>`         |
   | DateTimeField | 文本字段，值会被处理为 datetime.datetime 对象 |        `<input type='text'>`         |
   |   FileField   |                 文本上传字段                  |        `<input type='file'>`         |
   |  FloatField   |        浮点数字段，值会被处理为浮点型         |        `<input type='text'>`         |
   | IntegerField  |          整数字段，值会被处理为整型           |        `<input type='text'>`         |
   |  RadioField   |                 一组单选按钮                  |        `<input type='radio'>`        |
   |  SelectField  |                   下拉列表                    | `<select><option></option></select>` |
   |  SubmitField  |                   提交按钮                    |       `<input type='submit'>`        |
   |  StringField  |                   文本字段                    |        `<input type='text'>`         |
   |  HiddenField  |                 隐藏文本字段                  |       `<input type='hidden'>`        |
   | PasswordField |                 密码文本字段                  |      `<input type='password'>`       |
   | TextAreaField |                 多行文本字段                  |       `<textarea></textarea>`        |

8. 通过实例化字段类时传入的参数，我们可以对字段进行设置，字段类构造方法接收的常用参数下表所示。

   <center><b>实例化字段类常用参数</b></center>

   |    参数    |                             说明                             |
   | :--------: | :----------------------------------------------------------: |
   |   label    | 字段标签 `<label>` 的值，也就是渲染后显示在输入字段前面的文字 |
   | render_kw  | 一个字典，用来设置对应的 HTML `<input>` 标签的属性，比如传入 `{'placeholder': 'Your Name'}`，渲染后的 HTML 代码会将 `<input>` 标签的 placeholder 属性设为 Your Name |
   | validators | 一个列表，包含一系列验证器，会在表单提交后被逐一调用验证表单数据 |
   |  default   |         字符串或可调用对象，用来为表单字段设置默认值         |

9. 在 WTForms 中，验证器(validator)是一系列用于验证字段数据的类，我们在实例化字段类时使用 validators 关键字来指定附加的验证器列表。验证器从 wtforms.validators 模块中导入，常用的验证器如下表所示。

   |                       验证器                        |              说明              |
   | :-------------------------------------------------: | :----------------------------: |
   |             DataRequired(message=None)              |        验证数据是否有效        |
   |                 Email(message=None)                 |        验证 Email 地址         |
   |           EqualTo(filename, message=None)           |     验证两个字段值是否相同     |
   |             InputRequired(message=None)             |         验证是否有数据         |
   |        Length(min=-1, max=-1, message=None)         |   验证输入值是否在给定范围内   |
   |    NumberRange(min=None, max=None, message=None)    |  验证输入数字是否在给定范围内  |
   |           Optional(strip_whitespace=True)           | 允许输入值为空，并跳过其他验证 |
   |        Regexp(regex, flags=0, message=None)         |    使用正则表达式验证输入值    |
   |                URL(Require_tld=True)                |            验证 URL            |
   | AnyOf(values, message=None, values_formatter=None)  |    确保输入值在可选值列表中    |
   | NoneOf(values, message=None, values_formatter=None) |    确保输入值不在可选列表中    |

10. 在实例化验证类时，message 参数用来传入自定义错误消息，如果没有设置则使用内置的英文错误消息，后面我们会了解如何使用内置的中文错误消息。

11. validators 参数接收一个传入可调用对象组成的列表。内置的验证器 通过实现了 `__call__()` 方法的类表示，所以我们需要在验证器后添加括号。

12. 在 name 和 password 字段里，我们都使用了 DataRequired  验证器，用来验证输入的数据是否有效。另外，password 字段里还添加了一个 Length 验证器，用来验证输入的数据长度是否在给定的范围内。

13. 验证器的第一个参数一般为错误提示消息，我们可以使用 message 关键字传递参数，通过传入自定义错误信息来覆盖内置消息，比如：

    ```bash
    name = StringField('Your Name', validators=[DataRequired(message=u'名字不能为空！')
    ```

14. 当使用 Flask-WTF 定义表单时，我们仍然使用 WTForms 提供的字段 类和验证器，创建的方式也完全相同，只不过表单类要继承 Flask-WTF 提供的 FlaskForm 类。

15. FlaskForm 类继承自 Form 类，进行了一些设置，并附加了一些辅助方法，以便与 Flask 集成。

16. 因为本章的示例程序中包含多个表单类，为了便于组织，我们创建了一个 forms.py 脚本，用来存储所有的表单类。如下代码是继承 FlaskForm 类的 LoginForm 表单。

    ```python
    from flask_wtf import FlaskForm
    from wtforms import StringField, PasswordField, BooleanField, SubmitField
    from wtforms.validators import DataRequired, Length

    class LoginForm(FlaskForm):
        username = StringField('Username', validators=[DataRequired()])
        password = PasswordField('Password', validators=[DataRequired(), Length(8, 128)])
        remember = BooleanField('Remember me')
        submit = SubmitField('Log in')
    ```

17. 配置键 WTF_CSRF_ENABLED 用来设置是否开启 CSRF 保护，默认为 True 。Flask-WTF 会自动在实例化表单类时添加一个包含 CSRF 令牌值的隐藏字段，字段名为 csrf_token 。

### 4.3.2 输出 HTML 代码

1. 以我们使用 WTForms 创建的 LoginForm 为例，实例化表单类，然后将实例属性转换成字符串或直接调用就可以获取表单字段对应的 HTML 代码：

   ```python
   >>> form = LoginForm()
   >>> form.username()
   u'<input id="username" name="username" type="text" value="">'
   >>> form.submit()
   u'<input id="submit" name="submit" type="submit" value="Submit">'
   ```

2. 字段的 `<label>` 元素的 HTML 代码则可以通过 "form.字段名.label" 的形式获取：

   ```python
   >>> form.username.label()
   u'<label for="username">Username</label>'
   >>> form.submit.label()
   u'<label for="submit">Submit</label>'
   ```

3. 在创建 HTML 表单时，我们经常会需要使用 HTML `<input>` 元素的其他属性来对字段进行设置。

4. 比如，添加 class 属性设置对应的 CSS 类为字段添加样式；添加 placeholder 属性设置占位文本。默认情况下， WTForms 输出的字段 HTML 代码只会包含 id 和 name 属性，属性值均为表单类中对应的字段属性名称。如果要添加额外的属性，通常有两种方法。

#### 4.3.2.1 使用 render_kw 属性

1. 比如下面为 username 字段使用 render_kw 设置了 placeholder HTML 属性：

   ```python
   username = StringField('Username', render_kw={'placeholder': 'Your Username'})
   ```

2. 这个字段被调用后输出的 HTML 代码如下所示：

   ```html
   <input type="text" id="username" name="username" placeholder="Your Username">
   ```

#### 4.3.2.2 在调用字段时传入

1. 在调用字段属性时，通过添加括号使用关键字参数的形式也可以传入字段额外的 HTML 属性：

   ```python
   >>> form.username(style='width: 200px;', class_='bar')
   u'<input class="bar" id="username" name="username" style="width: 200px;" type="text" value="">'
   ```

2. class 是 Python 的保留关键字，在这里我们使用 class_ 来代替 class ，渲染后的 `<input>` 会获得正确的 class 属性，在模板中调用时则可以直接使用 class 。

3. 通过上面的方法也可以修改 id 和 name 属性，但表单被提交后，WTForms 需要通过 name 属性来获取对应的数据，所以不能修改 name 属性值。

### 4.3.3 在模板中渲染表单

1. 为了能够在模板中渲染表单，我们需要把表单类实例传入模板。首先在视图函数里实例化表单类 LoginForm ，然后在 render_template() 函数中使用关键字参数 form 将表单实例传入模板，如下代码所示。

   <center><b>form/app.py：传入表单类实例</b></center>

   ```python
   from forms import LoginForm

   @app.route('/basic')
   def basic():
       form = LoginForm()
       return render_template('login.html', form=form)
   ```

2. 在模板中，只需要调用表单类的属性即可获取字段对应的 HTML 代码，如果需要传入参数，也可以添加括号，如下所示。

   <center><b>form/templates/basic.html：在模板中渲染表单</b></center>

   ```html
   <form method="post">
       {{ form.csrf_token }}  <!-- 渲染CSRF令牌隐藏字段 -->
       {{ form.username.label }}{{ form.username }}<br>
       {{ form.password.label }}{{ form.password }}<br>
       {{ form.remember }}{{ form.remember.label }}<br>
       {{ form.submit }}<br>
   </form>
   ```

3. 需要注意的是，在上面的代码中，除了渲染各个字段的标签和字段本身，我们还调用了 form.csrf_token 属性渲染 Flask-WTF 为表单类自动创建的 CSRF 令牌字段。form.csrf_token 字段包含了自动生成的 CSRF 令牌值，在提交表单后会自动被验证，为了确保表单通过验证，我们必须在表单中手动渲染这个字段。

4. Flask-WTF 为表单类实例提供了一个 form.hidden_tag() 方法，这个方法会依次渲染表单中所有的隐藏字段。因为 csrf_token 字段也是隐藏字段，所以当这个方法被调用时也会渲染 csrf_token 字段。

5. 渲染后获得的实际 HTML 代码如下所示：

   ```html
   <form method="post">
       <input id="csrf_token" name="csrf_token" type="hidden" value="IjVmMDE1ZmFjM2VjYmZjY">

   <label for=" username">Username</label><br>
       <input id="username" name="username" type="text" value=""><br>
       <label for="password">Password</label><br>
       <input id="password" name="password" type="password" value=""><br>
       <input id="remember" name="remember" type="checkbox" value="y"><label for="remember">
           <input id="submit" name="submit" type="submit" value="Log in"><br>
   </form>
   ```

6. 如果你运行了示例程序，访问 <http://localhost:5000/basic> 可以看到渲染后的表单，页面中的表单和我们在上面使用 HTML 编写的表单完全相同。

7. 在前面我们介绍过，使用 render_kw 字典或是在调用字段时传入参数来定义字段的额外 HTML 属性，通过这种方式添加 CSS 类，我们可以编写一个 Bootstrap 风格的表单，如下代码所示。

   ```html
   ...
   <form method="post">
       {{ form.csrf_token }} {{ form.username.label }}
       <div class="form-group">
           {{ form.username(class='form-control') }} </div>
       <div class="form-group">
           {{ form.password.label }}
           {{ form.password(class='form-control') }}
       </div>
       <div class="form-check">
           {{ form.remember(class='form-check-input') }}
           {{ form.remember.label }} </div> {{ form.submit(class='btn btn-primary') }}
   </form>
   ...
   ```

8. 为了使用 Bootstrap ，我们在模板中加载了 Bootstrap 资源。如果你运行了示例程序，可以访问 <http://localhost:5000/bootstrap> 查看渲染后的实际效果。

9. 如果你想手动编写 HTML 表单的代码，要注意表单字段的 name 属性值必须和表单类的字段名称相同，这样在提交表单时 WTForms 才能正确地获取数据并进行验证，具体会在后面介绍。

## 4.4 处理表单数据

1. 表单数据的处理涉及很多内容，除去表单提交不说，从获取数据到保存数据大致会经历以下步骤：
   - 解析请求，获取表单数据。
   - 对数据进行必要的转换，比如将勾选框的值转换成 Python 的布尔值。
   - 验证数据是否符合要求，同时验证 CSRF 令牌。
   - 如果验证未通过则需要生成错误消息，并在模板中显示错误消息。
   - 如果通过验证，就把数据保存到数据库或做进一步处理。 除非是简单的程序，否则手动处理不太现实，使用 Flask-WTF 和 WTForms 可以极大地简化这些步骤。

### 4.4.1 提交表单

1. 在 HTML 中，当 `<form>` 标签声明的表单中类型为 submit 的提交字段被单击时，就会创建一个提交表单的 HTTP 请求，请求中包含表单各个字段的数据。表单的提交行为主要由三个属性控制，如下表所示。

   ​    **HTML 表单中控制提交行为的属性**

   |  属性   |              默认值              |                             说明                             |
   | :-----: | :------------------------------: | :----------------------------------------------------------: |
   | action  |    当前 URL，即页面对应的 URL    |                 表单提交时发送请求的目的 URL                 |
   | method  |               get                |  提交表单的 HTTP 请求方法，目前仅支持使用 GET 和 POST 方法   |
   | enctype | application/x-www-form-urlencode | 表单数据的编码类型，当表单中包含文件上传字段时，需要设为 multipart/form-data，还可以设为纯文本类型 text/plain |

2. form 标签的 action 属性用来指定表单被提交的目标 URL ，默认为当前 URL ，也就是渲染该模板的路由所在的 URL 。如果你要把表单数据发送到其他 URL ，可以自定义这个属性值。

3. 当使用 GET 方法提交表单数据时，表单的数据会以查询字符串的形式附加在请求的 URL 里，比如：

   - <http://localhost:5000/basic?username=greyli&password=12345>

4. GET 方式仅适用于长度不超过 3000 个字符，且不包含敏感信息的表单。因为这种方式会直接将用户提交的表单数据暴露在 URL 中，容易被攻击者截获，示例中的情况明显是危险的。因此，出于安全的考虑，我们一般使用 POST 方法提交表单。使用 POST 方法时，按照默认的编码类型，表单数据会被存储在请求主体中，比如：

   ```text
   POST /basic HTTP/1.0
   ...
   Content-Type: application/x-www-form-urlencoded
   Content-Length: 30

   username=greyli&password=12345
   ```

5. 在第 2 章我们介绍过，Flask 为路由设置默认监听的 HTTP 方法为 GET。为了支持接收表单提交发送的 POST 请求，我们必须在 app.route() 装饰器里使用 methods 关键字为路由指定 HTTP 方法，如下所示。

   ```python
   @app.route('/', methods=['GET', 'POST'])
   def basic():
       form = LoginForm()
       return render_template('basic.html', form=form)
   ```

### 4.4.2 验证表单数据

1. 表单数据的验证是 Web 表单中最重要的主题之一，这一节我们会学习如何使用 Flask-WTF 验证并获取表单数据。

#### 4.4.2.1 客户端验证和服务器端验证

1. 表单的验证通常分为以下两种形式：

- **客户端验证**

  - 客户端验证(client side validation) 是指在客户端(比如 Web 浏览器)对用户的输入值进行验证。比如，使用 HTML5 内置的验证属性即可实现基本的客户端验证(type、required、min、max、accept等)。比如，下面的 username 字段添加了 required 标志：

    ```html
    <input type="text" name="username" required>
    ```

  - 如果用户没有输入内容而按下提交按钮，会弹出浏览器内置的错误提示。

  - 和其他附加 HTML 属性相同，我们可以在定义表单时通过 render_kw 传入这些属性，或是在渲染表单时传入。像 required 这类布尔值属性，值可以为空或是任意 ASCII 字符，比如：

    ```jinja2
    {{ form.username(required='') }}
    ```

  - 除了使用 HTML5 提供的属性实现基本的客户端验证，我们通常会使用 JavaScript 实现完善的验证机制。如果你不想手动编写 JavaScript 代码实现客户端验证，可以考虑使用各种 JavaScript 表单验证库，比如 [jQuery Validation Plugin](https://jqueryvalidation.org/)、 [Parsley.js](http://parsleyjs.org/) 以及可与 [Bootstrap 集成的 Bootstrap Validator](http://1000hz.github.io/bootstrap-validator/，目前仅支持 Bootstrap 3 版本)等。

  - 客户端方式可以实时动态提示用户输入是否正确，只有用户输入正确后才会将表单数据发送到服务器。客户端验证可以增强用户体验，降低服务器负载。

- **服务器端验证**

  - 服务器端验证(server side validation)是指用户把输入的数据提交到服务器端，在服务器端对数据进行验证。如果验证出错，就在返回的响应中加入错误信息。用户修改后再次提交表单，直到通过验证。我们在 Flask 程序中使用 WTForms 实现的就是服务器端验证。
  - 在这里我们不必纠结使用何种形式，因为无论你是否使用客户端验证，服务器端验证都是必不可少的，因为用户可以通过各种方式绕过客户端验证，比如在客户端设置禁用 JavaScript 。对于玩具程序来说，你可以不用考虑那么多，但对于真实项目来说，绝对不能忽视任何安全问题。因为客户端验证超出了本书介绍的范围，这里仅介绍服务器端验证的实现。

#### 4.4.2.2 WTForms 验证机制

1. WTForms 验证表单字段的方式是在实例化表单类时传入表单数据，然后对表单实例调用 validate() 方法。

2. 这会逐个对字段调用字段实例化时定义的验证器，返回表示验证结果的布尔值。如果验证失败，就把错误消息存储到表单实例的 errors 属性对应的字典中，验证的过程如下所示：

   ```python
   >>> from wtforms import Form, StringField, PasswordField, BooleanField
   >>> from wtforms.validators import DataRequired, Length
   >>> class LoginForm(Form):
   ... username = StringField('Username', validators=[DataRequired()])
   ... password = PasswordField('Password', validators=[DataRequired() , Length(8, 128)])
   >>> form = LoginForm(username='', password='123')
   >>> form.data # 表单数据字典
   {'username': '', 'password': '123'}
   >>> form.validate()
   False
   >>> form.errors # 错误消息字典
   {'username': [u'This field is required.'], 'password': [u'Field must be at least 6 characters long.']}
   >>> form2 = LoginForm(username='greyli', password='123456')
   >>> form2.data
   {'username': 'greyli', 'password': '123456'}
   >>> form2.validate() True
   >>> form2.errors
   {}
   ```

3. 因为我们的表单使用 POST 方法提交，如果单纯使用 WTForms ，我们在实例化表单类时需要首先把 request.form 传入表单类，而使用 FlaskWTF 时，表单类继承的 FlaskForm 基类默认会从 request.form 获取表单数据，所以不需要手动传入。

4. 使用 POST 方法提交的表单，其数据会被 Flask 解析为一个字典，可以通过请求对象的 form 属性获取(request.form)；使用 GET 方法提交的表单的数据同样会被解析为字典，不过要通过请求对象的 args 属性获取(request.args)。

#### 4.4.2.3 在视图函数中验证表单

1. 因为现在的 basic_form 视图同时接收两种类型的请求：GET 请求和 POST 请求。所以我们要根据请求方法的不同执行不同的代码。具体来说：首先是实例化表单，如果是 GET 请求，那么就渲染模板；如果是 POST 请求，就调用 validate() 方法验证表单数据。

2. 请求的 HTTP 方法可以通过 request.method 属性获取，我们可以使用下面的方式来组织视图函数：

   ```python
   from flask import request
   ...

   @app.route('/basic', methods=['GET', 'POST'])
   def basic():
       form = LoginForm() # GET + POST
       if request.method == 'POST' and form.validate():
           ... # 处理POST请求
       return render_template('forms/basic.html', form=form) # 处理GET请求
   ```

3. 其中的 if 语句等价于：

   ```text
   if 用户提交表单 and 数据通过验证:
   获取表单数据并保存
   ```

4. 当请求方法是 GET 时，会跳过这个 if 语句，渲染 basic.html 模板；当请求的方法是 POST 时(说明用户提交了表单)，则验证表单数据。这会逐个字段(包括 CSRF 令牌字段)调用附加的验证器进行验证。

5. 因为 WTForms 会自动对 CSRF 令牌字段进行验证，如果没有渲染该字段会导致验证出错，错误消息为 "CSRF token is missing"。

6. Flask-WTF 提供的 validate_on_submit() 方法合并了这两个操作，因此上面的代码可以简化为：

   ```python
   @app.route('/basic', methods=['GET', 'POST'])
   def basic():
       form = LoginForm()
       if form.validate_on_submit():
           ...
       return render_template('basic.html', form=form)
   ```

7. 除了 POST 方法，如果请求的方法是 PUT、PATCH 和 DELETE 方法，form.validate_on_submit() 也会验证表单数据。

8. 如果 form.validate_on_submit() 返回 True ，则表示用户提交了表单，且表单通过验证，那么我们就可以在这个 if 语句内获取表单数据，如下所示。

   <center><b>form/app.py：表单验证与获取数据</b></center>

   ```python
   from flask import Flask, render_template, redirect, url_for, flash
   ...
   @app.route('/basic', methods=['GET', 'POST'])
   def basic():
       form = LoginForm()
       if form.validate_on_submit():
           username = form.username.data
           flash('Welcome home, %s!' % username)
           return redirect(url_for('index'))
       return render_template('basic.html', form=form)
   ```

9. 表单类的 data 属性是一个匹配所有字段与对应数据的字典，我们一般直接通过 "form.字段属性名.data" 的形式来获取对应字段的数据。

10. 例如，form.username.data 返回 username 字段的值。在代码中，当表单验证成功后，我们获取了 username 字段的数据，然后用来发送一条 flash 消息，最后将程序重定向到 index 视图。

11. 表单的数据一般会存储到数据库中，这是我们下一章要学习的内容。这里仅仅将数据填充到 flash() 函数里。

12. 在这个 if 语句内，如果不使用重定向的话，当 if 语句执行完毕后会继续执行最后的 render_template() 函数渲染模板，最后像往常一样返回一个常规的 200 响应，但这会造成一个问题：

    - 在浏览器中，当单击 F5 刷新/重载时的默认行为是发送上一个请求。如果上一个请求是 POST 请求，那么就会弹出一个确认窗口，询问用户是否再次提交表单。
    - 为了避免出现这个容易让人产生困惑的提示，我们尽量不要让提交表单的 POST 请求作为最后一个请求。这就是为什么我们在处理表单后返回一个重定向响应，这会让浏览器重新发送一个新的 GET 请求到重定向的目标 URL 。最终，最后一个请求就变成了 GET 请求。
    - 这种用来防止重复提交表单的技术称为 PRG(Post/Redirect/Get) 模式，即通过对提交表单的 POST 请求返回重定向响应将最后一个请求转换为 GET 请求。

### 4.4.3 在模板中渲染错误消息

1. 如果 form.validate_on_submit() 返回 False ，那么说明验证没有通过。

2. 对于验证未通过的字段，WTForms 会把错误消息添加到表单类的 errors 属性中，这是一个匹配作为表单字段的类属性到对应的错误消息列表的字典。我们一般会直接通过字段名来获取对应字段的错误消息列表，即 "form.字段名.errors" 。

3. 比如，form.name.errors 返回 name 字段的错误消息列表。像第 2 章渲染 flash() 消息一样，我们可以在模板里使用 for 循环迭代错误消息列表，如代码所示。

   <center><b>form/templates/basic.html：渲染错误消息</b></center>

   ```html
   <form method="post">
       {{ form.csrf_token }}
       x{{ form.username.label }}<br>
       {{ form.username() }}<br>
       {% for message in form.username.errors %}
           <small class="error">{{ message }}</small><br>
       {% endfor %}
       {{ form.password.label }}<br>
       {{ form.password }}<br>
       {% for message in form.password.errors %}
           <small class="error">{{ message }}</small><br>
       {% endfor %}
       {{ form.remember }}{{ form.remember.label }}<br>
       {{ form.submit }}<br>
   </form>
   ```

4. 为了让错误消息更加醒目，我们为错误消息元素添加了 error 类，这 个样式类在 style.css 文件中定义，它会将文字颜色设为红色。

5. 如果你运行了示例程序，请访问 <http://localhost:5000/basic> 打开基本表单示例，如果你没有输入内容而按下提交按钮，会看到浏览器内置的错误提示。

6. 在使用 DataRequired 和 InputRequired 验证器时，WTForms 会在字段输出的 HTML 代码中添加 required 属性，所以会弹出浏览器内置的错误提示。

7. 同时，WTForms 也会在表单字段的 flags 属性添加 required 标志(比如 form.username.flags.required)，所以我们可以在模板中通过这个标志值来判断是否在字段文本中添加一个 `*` 号或文字标注，以表示必填项。

8. 如果你在用户名字段输入空格，在密码字段输入的数值长度小于 6，返回响应后会看到对应的错误消息显示在字段下方

9. InputRequired 验证器和 DataRequired 很相似，但 InputRequired 仅验证用户是否有输入，而不管输入的值是否有效。例如，由空格组成的数据也会通过验证。当使用 DataRequired 时，如果用户输入的数据不符合字段要求，比如在 IntegerField 输入非数字时会视为未输入，而不是类型错误。

10. 至此，我们已经介绍了在 Python 中处理 HTML 表单的所有基本内容。完整的表单处理过程的流程图如下所示。

    <img src="https://studentcwz-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="表单处理流程图" style="zoom: 50%;" />

## 4.5 表单进阶实践

1. 这一节会介绍表单处理的相关技巧，这些技巧可以简化表单的处理过程。另外，我们还介绍了表单的一些非常规应用。

### 4.5.1 设置错误消息语言

1. WTForms 内置了多种语言的错误消息，如果你想改变内置错误消息的默认语言，可以通过自定义表单基类实现(Flask-WTF 版本 > 0.14.2)。

2. 实现这个功能需要确保 Flask-WTF 版本 > 0.14.2 或单独使用 WTForms 。在本书写作时，Flask-WTF 的最新版本为 0.14.2 ，所以这里介绍的方法暂时无法使用。

3. 下面代码中的示例程序创建了一个 MyBaseForm 基类，所有继承这个基类的表单类的内置错误消息语言都会设为简体中文。

   <center><b>设置内置错误消息语言为中文</b></center>

   ```python
   from flask_wtf import FlaskForm

   app = Flask(__name__)

   app.config['WTF_I18N_ENABLED'] = False

   class MyBaseForm(FlaskForm):
       class Meta:
           locales = ['zh']

   class HelloForm(MyBaseForm):
       name = StringField('Name', validators=[DataRequired()])
       submit = SubmitField()
   ```

4. 首先，我们需要将配置变量 WTF_I18N_ENABLED 设为 False ，这会让 Flask-WTF 使用 WTForms 内置的错误消息翻译。然后我们需要在自定义基类中定义 Meta 类，并在 locales 列表中加入简体中文的地区字符串。

5. 在创建表单时，继承这个 MyBaseForm 即可将错误消息语言设为中文，比如上面定义的 HelloForm 。另外，你也可以在实例化表单类时通过 meta 关键字传入 locales 值，比如：

   ```python
   form = MyForm(meta={'locales': ['en_US', 'en']})
   ```

6. locales 属性是一个根据优先级排列的地区字符串列表。在 WTForms 中，简体中文和繁体中文的地区字符串分别为 zh 和 zh_TW 。

7. 在本书的第二部分，我们将学习为 Flask 程序添加国际化和本地化支持，这样程序会根据用户的语言偏好来自动显示正确的语言，而不是固定使用某一种语言。

### 4.5.2 使用宏渲染表单

1. 在模板中渲染表单时，我们有大量的工作要做：

   - 调用字段属性，获取 `<input>` 定义。

   - 调用对应的 label 属性，获取 `<label>` 定义。

   - 渲染错误消息。为了避免为每一个字段重复这些代码，我们可以创建一个宏来渲染表单字段，如下所示。

     <center><b>macros.html：表单渲染宏</b></center>

     ```jinja2
     {% macro form_field(field) %}
     {{ field.label }}<br>
     {{ field(**kwargs) }}<br>
     {% if field.errors %}
         {% for error in field.errors %}
             <small class="error">{{ error }}</small><br>
         {% endfor %}
     {% endif %}
     {% endmacro %}
     ```

2. 这个 form_field() 宏接收表单类实例的字段属性和附加的关键字参数作为输入，返回包含 `<label>` 标签、表单字段、错误消息列表的 HTML 表单字段代码。

3. 使用这个宏渲染表单的示例如下所示：

   ```jinja2
   {% from 'macros.html' import form_field %}
   ...
   <form method="post">
       {{ form.csrf_token }}
       {{ form_field(form.username)}}<br>
       {{ form_field(form.password) }}<br>
       ...
   </form>
   ```

4. 在上面的代码中，我们调用 form_field() 宏逐个渲染表单中的字段，只要把每一个类属性传入 form_field() 宏，即可完成渲染。

5. 同样的，我们可以编写一个宏渲染 Bootstrap 风格的表单。不过，这类复杂的工作可以交给扩展来完成，后面我们会介绍使用扩展简化在模板中渲染 Bootstrap 风格表单的工作。

### 4.5.3 自定义验证器

1. 在 WTForms 中，验证器是指在定义字段时传入 validators 参数列表的可调用对象，这一节我们会介绍如何编写自定义验证器。

#### 4.5.3.1 行内验证器

1. 除了使用 WTForms 提供的验证器来验证表单字段，我们还可以在表单类中定义方法来验证特定字段，如下所示。

   <center><b>form/forms.py：针对特定字段的验证器</b></center>

   ```python
   from wtforms import IntegerField, SubmitField
   from wtforms.validators import ValidationError

   class FortyTwoForm(FlaskForm):
       answer = IntegerField('The Number')
       submit = SubmitField()

   def validate_answer(form, field):
       if field.data != 42:
           raise ValidationError('Must be 42.')
   ```

2. 当表单类中包含以 "validate_ 字段属性名" 形式命名的方法时，在验证字段数据时会同时调用这个方法来验证对应的字段，这也是为什么表单类的字段属性名不能以 validate 开头。

3. 验证方法接收两个位置参数，依次为 form 和 field ，前者为表单类实例，后者是字段对象，我们可以通过 field.data 获取字段数据，这两个参数将在验证表单时被调用传入。

4. 验证出错时抛出从 wtforms.validators 模块导入的 ValidationError 异常，传入错误消息作为参数。因为这种方法仅用来验证特定的表单类字段，所以又称为行内验证器(in-line validator)

#### 4.5.3.2 全局验证器

1. 如果你想要创建一个可重用的通用验证器，可以通过定义一个函数实现。如果不需要传入参数定义验证器，那么一个和表单类中定义的验证方法完全相同的函数就足够了，如下所示。

   <center><b>全局验证器示例</b></center>

   ```python
   from wtforms.validators import ValidationError

   def is_42(form, field):
       if field.data != 42:
           raise ValidationError('Must be 42')

   class FortyTwoForm(FlaskForm):
       answer = IntegerField('The Number', validators=[is_42])
       submit = SubmitField()
   ```

2. 当使用函数定义全局的验证器时，我们需要在定义字段时在 validators 列表里传入这个验证器。因为在 validators 列表中传入的验证器必须是可调用对象，所以这里传入了函数对象，而不是函数调用。

3. 这仅仅是一个简单的示例，在现实中，我们通常需要让验证器支持传入参数来对验证过程进行设置。至少，我们应该支持 message 参数来 设置自定义错误消息。这时验证函数应该实现成工厂函数，即返回一个可调用对象的函数，如下所示。

   <center><b>工厂函数形式的全局验证器示例</b></center>

   ```python
   from wtforms.validators import ValidationError

   def is_42(message=None):
       if message is None:
           message = 'Must be 42.'

       def _is_42(form, field):
            if field.data != 42:
                raise ValidationError(message)

        return _is_42

   class FortyTwoForm(FlaskForm):
       answer = IntegerField('The Number', validators=[is_42()])
       submit = SubmitField()
   ```

4. 在现在的 is_42() 函数中，我们创建了另一个 _is_42() 函数，这个函数会被作为可调用对象返回。is_42() 函数接收的 message 参数用来传入自定义错误消息，默认为 None ，如果没有设置就使用内置消息。在 validators 列表中，这时需要传入的是对工厂函数 is_42() 的调用。

5. 在更复杂的验证场景下，你可以使用实现了 `__call__()` 方法的类(可调用类)来编写验证器，具体请参考 [WTForms 文档相关章节](<http://wtforms.readthedocs.io/en/latest/validators.html#customvalidators>)。

### 4.5.4 文件上传

1. 在 HTML 中，渲染一个文件上传字段只需要将 `<input>` 标签的 type 属性设为 file ，即 `<input type="file">` 。这会在浏览器中渲染成一个文件上传字段，单击文件选择按钮会打开文件选择窗口，选择对应的文件后，被选择的文件名会显示在文件选择按钮旁边。
2. 在服务器端，可以和普通数据一样获取上传文件数据并保存。不过我们需要考虑安全问题，文件上传漏洞也是比较流行的攻击方式。除了常规的 CSRF 防范，我们还需要重点注意下面的问题：
   - 验证文件类型。
   - 验证文件大小。
   - 过滤文件名。

#### 4.5.4.1 定义上传表单

1. 在 Python 表单类中创建文件上传字段时，我们使用扩展 Flask-WTF 提供的 FileField 类，它继承 WTForms 提供的上传字段 FileField ，添加了对 Flask 的集成。下面代码创建了一个包含文件上传字段的表单。

   <center><b>form/forms.py：创建上传表单</b></center>

   ```python
   from flask wtf.file import FileField, FileRequired, FileAllowed

   class UploadForm(FlaskForm):
      photo = FileField('Upload Image', validators=[FileRequired(), FileAllowed(['jpg', 'jpg'])]
      submit = SubmitField()
   ```

2. 为了便于测试，我们创建一个用来上传图片的 photo 字段。和其他字段类似，我们也需要对文件上传字段进行验证。Flask-WTF 在 flask_wtf.file 模块下提供了两个文件相关的验证器，用法说明如下表所示。

   <center><b>Flask-WTF 提供的上传文件验证器</b></center>

   |                验证器                 |                             说明                             |
   | :-----------------------------------: | :----------------------------------------------------------: |
   |      FileRequired(message=None)       |                     验证是否包含文件对象                     |
   | FileAllowed(upload_set, message=None) | 用来验证文件类型，upload_set 参数用来传入包含允许的文件后缀名列表 |

3. 我们使用 FileRequired 确保提交的表单字段中包含文件数据。出于安全考虑，我们必须对上传的文件类型进行限制。

4. 如果用户可以上传 HTML 文件，而且我们同时提供了视图函数获取上传后的文件，那么很容易导致 XSS 攻击。我们使用 FileAllowed 设置允许的文件类型，传入一个包含允许文件类型的后缀名列表。

5. 顺便说一下，Flask-WTF 提供的 FileAllowed 是在服务器端验证上传文件，使用 HTML5 中的 accept 属性也可以在客户端实现简单的类型过滤。这个属性接收 MIME 类型字符串或文件格式后缀，多个值之间使用逗号分隔，比如：

   ```html
   <input type="file" id="profile_pic" name="profile_pic" accept=".jpg, .jpeg, .png, .gif">
   ```

6. 当用户单击文件选择按钮后，打开的文件选择窗口会默认将 accept 属性值之外的文件过滤掉。尽管如此，用户还是可以选择设定之外的文件，所以我们仍然需要进行服务器端验证。

7. 扩展 [Flask-Uploads](https://github.com/maxcountryman/flaskuploads)内置了在 Flask 中实现文件上传的便利功能。

8. Flask-WTF 提供的 FileAllowed() 也支持传入 Flask-Uploads 中的上传集对象(Upload Set)作为 upload_set 参数的值。另外，同类的扩展还有 [FlaskTransfer](https://github.com/justanr/Flask-Transfer)。

9. 除了验证文件的类型，我们通常还需要对文件大小进行验证，你肯定不想让用户上传超大的文件来拖垮你的服务器。通过设置 Flask 内置的配置变量 MAX_CONTENT_LENGTH ，我们可以限制请求报文的最大长度，单位为字节(byte)。比如，下面将最大长度限制为 3 M：

   ```python
   app.config['MAX_CONTENT_LENGTH'] = 3 * 1024 * 1024
   ```

10. 当请求数据(上传文件大小)超过这个限制后，会返回 413 错误响应(Request Entity Too Large)

11. 我们可以创建对应的错误处理函数来返回自定义的 413 错误响应。需要注意，Flask 内置的开发服务器在抛出对应的异常时不会返回 413 响应，而是中断连接。

12. 不过我们不用担心这个问题，当使用生产环境下的服务器时，会正确返回 413 错误响应。

#### 4.5.4.2 渲染上传表单

1. 在新创建的 upload 视图里，我们实例化表单类 UploadForm ，然后传入模板：

   ```python
   @app.route('/upload', methods=['GET', 'POST'])
   def upload():
       form = UploadForm()
       ...
       return render_template('upload.html', form=form)
   ```

2. 下面代码在模板中渲染了这个表单，渲染方式和其他字段相同。

   <center><b>form/templates/upload.html：在模板中渲染上传表单</b></center>

   ```html
   <form method="post" enctype="multipart/form-data">
       {{ form.csrf_token }}
       {{ form_field(form.photo) }}
       {{ form.submit }}
   </form>
   ```

3. 唯一需要注意的是，当表单中包含文件上传字段时(即 type 属性为 file 的 input 标签)，需要将表单的 enctype 属性设为 "multipart/form-data"， 这会告诉浏览器将上传数据发送到服务器，否则仅会把文件名作为表单数据提交。

### 4.5.4.3 处理上传文件

1. 和普通的表单数据不同，当包含上传文件字段的表单提交后，上传 的文件需要在请求对象的 files 属性(request.files)中获取。我们在第 2 章介绍过，这个属性是 Werkzeug 提供的 ImmutableMultiDict 字典对象，存储字段的 name 键值和文件对象的映射，比如：

   ```python
   ImmutableMultiDict([('photo', <FileStorage: u'0f913b0ff95.JPG' ('image/jpeg')>)])
   ```

2. 上传的文件会被 Flask 解析为 Werkzeug 中的 FileStorage 对象(werkzeug.datastructures.FileStorage)。当手动处理时，我们需要使用文件上传字段的 name 属性值作为键获取对应的文件对象。比如：

   ```python
   request.files.get('photo')
   ```

3. 当使用 Flask-WTF 时，它会自动帮我们获取对应的文件对象，这里我们仍然使用表单类属性的 data 属性获取上传文件。处理上传表单提交请求的 upload 视图如下代码所示。

   <center><b>form/app.py：处理上传文件</b></center>

   ```python
   import os

   app.config['UPLOAD_PATH'] = os.path.join(app.root_path, 'uploads')

   @app.route('/upload', methods=['GET', 'POST'])
   def upload():
       form = UploadForm()
       if form.validate_on_submit():
           f = form.photo.data filename = random_filename(f.filename)
           f.save(os.path.join(app.config['UPLOAD_PATH'], filename))
           flash('Upload success.')
           session['filenames'] = [filename]
           return redirect(url_for('show_images'))
       return render_template('upload.html', form=form)
   ```

4. 当表单通过验证后，我们通过 form.photo.data 获取存储上传文件的 FileStorage 对象。接下来，我们需要处理文件名，通常有三种处理方式：

   - 使用原文件名

     - 如果能够确定文件的来源安全，可以直接使用原文件名，通过 FileStorage 对象的 filename 属性获取：

       ```python
       filename = f.filename
       ```

   - 使用过滤后的文件名

     - 如果要支持用户上传文件，我们必须对文件名进行处理，因为攻击者可能会在文件名中加入恶意路径。比如，如果恶意用户在文件名中加入表示上级目录的 ..(比如 ../../../../home/username/.bashrc 或 ../../../etc/passwd)，那么当我们保存文件时，如果这里表示上级目录的 .. 数量正确，就会导致服务器上的系统文件被覆盖或篡改，还有可能执行恶意脚本。

     - 我们可以使用 Werkzeug 提供的 secure_filename() 函数对文件名进行过滤，传递文件名作为参数，它会过滤掉所有危险字符，返回安全的文件名，如下所示：

       ```python
       >>> from werkzeug import secure_filename

       >>> secure_filename('avatar!@#//#\\%$^&.jpg')
       'avatar.jpg'
       >>> secure_filename('avatar头像.jpg')
       'avatar.jpg'
       ```

   - 统一重命名

     - secure_filename() 函数非常方便，它会过滤掉文件名中的非 ASCII 字符。但如果文件名完全由非 ASCII 字符组成，那么会得到一个空文件 名：

       ```python
       >>> secure_filename('头像.jpg')
       'jpg'
       ```

     - 为了避免出现这种情况，更好的做法是使用统一的处理方式对所有上传的文件重新命名。随机文件名有很多种方式可以生成，下面是一个使用 Python 内置的 uuid 模块生成随机文件名的 random_filename() 函数：

       ```python
       def random_filename(filename):
           ext = os.path.splitext(filename)[1]
           new_filename = uuid.uuid4().hex + ext
           return new_filename
       ```

     - 这个函数接收原文件名作为参数，使用内置的 uuid 模块中的 uuid4() 方法生成新的文件名，并使用 hex 属性获取十六进制字符串，最后返回包含后缀的新文件名。

5. UUID(Universally Unique Identifier，通用唯一识别码)是用来标识信息的 128 位数字，比如用作数据库表的主键。使用标准方法生成的 UUID 出现重复的可能性接近 0 。在 UUID 的标准中，UUID 分为 5 个版 本，每个版本使用不同的生成方法并且适用于不同的场景。我们使用的 uuid4() 方法对应的是第4个版本：不接收参数而生成随机 UUID 。

6. 在 upload 视图中，我们调用这个函数来获取随机文件名，传入原文件名作为参数：

   ```python
   filename = random_filename(f.filename)
   ```

7. 处理完文件名后，是时候将文件保存到文件系统中了。我们在 form 目录下创建了一个 uploads 文件夹，用于保存上传后的文件。指向这个文件夹的绝对路径存储在自定义配置变量 UPLOAD_PATH 中：

   ```python
   app.config['UPLOAD_PATH'] = os.path.join(app.root_path, 'uploads')
   ```

8. 这里的路径通过 app.root_path 属性构造，它存储了程序实例所在脚本的绝对路径，相当于 `os.path.abspath(os.path.dirname(__file__))`。为了保存文件，你需要提前手动创建这个文件夹。

9. 对 FileStorage 对象调用 save() 方法即可保存，传入包含目标文件夹绝对路径和文件名在内的完整保存路径：

   ```python
   f.save(os.path.join(app.config['UPLOAD_PATH'], filename))
   ```

10. 文件保存后，我们希望能够显示上传后的图片。为了让上传后的文件能够通过URL获取，我们还需要创建一个视图函数来返回上传后的文件，如下所示：

    ```python
    @app.route('/uploads/<path:filename>')
    def get_file(filename):
        return send_from_directory(app.config['UPLOAD_PATH'], filename)
    ```

11. 这个视图的作用与 Flask 内置的 static 视图类似，通过传入的文件路径返回对应的静态文件。在这个 uploads 视图中，我们使用 Flask 提供的 send_from_directory() 函数来获取文件，传入文件的路径和文件名作为参数。

12. 在 get_file 视图的 URL 规则中，filename 变量使用了 path 转换器以支持传入包含斜线的路径字符串。

13. 在 upload 视图里保存文件后，我们使用 flash() 发送一个提示，将文件名保存到 session 中，最后重定向到 show_images 视图。show_images 视图返回的 uploaded.html 模板中将从 session 获取文件名，渲染出上传后的图片。

    ```python
    flash('Upload success.')
    session['filenames'] = [filename]
    return redirect(url_for('show_images'))
    ```

14. 这里将 filename 作为列表传入 session 只是为了兼容下面的多文件上传示例，这两个视图使用同一个模板，使用 session 可以在模板中统一从 session 获取文件名列表。

15. 在 uploaded.html 模板里，我们将传入的文件名作为 URL 变量，通过上面的 get_file 视图获取文件 URL ，作为 `<img>` 标签的 src 属性值，如下所示：

    ```python
    <img src="{{ url_for('get_file', filename=filename) }}">
    ```

16. 访问 <http://localhost:5000/upload> 打开文件上传示例，选择文件并提交后即可看到上传后的图片。另外，你会在示例程序文件夹中的 uploads 目录下发现上传的文件。

#### 4.5.4.4 多文件上传

1. 因为 Flask-WTF 当前版本(0.14.2)中并未添加对多文件上传的渲染和验证支持，因此我们需要在视图函数中手动获取文件并进行验证。这种手动处理方式和我们在上一节介绍的方式效果基本相同。

2. 在客户端，通过在文件上传字段(type=file)加入 multiple 属性，就可以开启多选：

   ```html
   <input type="file" id="file" name="file" multiple>
   ```

3. 创建表单类时，可以直接使用 WTForms 提供的 MultipleFileField 字段实现，添加一个 DataRequired 验证器来确保包含文件：

   ```python
   from wtforms import MultipleFileField

   class MultiUploadForm(FlaskForm):
      photo = MultipleFileField('Upload Image', validators={DataRequired()})
      submit = SubmitField()
   ```

4. 表单提交时，在服务器端的程序中，对 request.files 属性调用 getlist() 方法并传入字段的 name 属性值会返回包含所有上传文件对象的列表。在 multi_upload 视图中，我们迭代这个列表，然后逐一对文件进行处理，如下代码所示。

   <center><b>form/app.py：处理多文件上传</b></center>

   ```python
   from flask import request, session, flash, redirect, url_for
   from flask_wtf.csrf import validate_csrf
   from wtforms import ValidationError

   @app.route('/multi-upload', methods=['GET', 'POST'])
   def multi_upload():
       form = MultiUploadForm()
       if request.method == 'POST':
           filenames = [] # 验证CSRF令牌
           try:
               validate_csrf(form.csrf_token.data)
           except ValidationError:
               flash('CSRF token error.')
               return redirect(url_for('multi_upload')) # 检查文件是否存在
           if 'photo' not in request.files:
               flash('This field is required.')
               return redirect(url_for('multi_upload'))

           for f in request.files.getlist('photo'):  # 检查文件类型
               if f and allowed_file(f.filename):
                   filename = random_filename(f.filename)
                   f.save(os.path.join( app.config['UPLOAD_PATH'], filename ))
                   filenames.append(filename)
               else:
                   flash('Invalid file type.')
                   return redirect(url_for('multi_upload'))
           flash('Upload success.')
           session['filenames'] = filenames
           return redirect(url_for('show_images'))
        return render_template('upload.html', form=form)
   ```

5. 在请求方法为 POST 时，我们对上传数据进行手动验证，主要包含下面几步：

   - 手动调用 flask_wtf.csrf.validate_csrf 验证 CSRF 令牌，传入表单中 csrf_token 隐藏字段的值。如果抛出 wtforms.ValidationError 异常则表明验证未通过。

   - 其中 if 'photo' not in request.files 用来确保字段中包含文件数据(相当于 FileRequired 验证器)，如果用户没有选择文件就提交表单则  request.files 将为空。

   - if f 用来确保文件对象存在，这里也可以检查 f 是否是 FileStorage 实例。

   - allowed_file(f.filename)调用了 allowed_file() 函数，传入文件名。这个函数相当于 FileAllowed 验证器，用来验证文件类型，返回布尔值，如下代码所示。

     <center><b>form/app.py：验证文件类型</b></center>

     ```python
     app.config['ALLOWED_EXTENSIONS'] = ['png', 'jpg', 'jpeg', 'gif']
     ...
     def allowed_file(filename):
        return '.' in filename and \ filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']
     ```

6. 在上面的几个验证语句里，如果没有通过验证，我们使用 flash() 函数显示错误消息，然后重定向到 multi_upload 视图。

7. 为了方便测试，我们还创建了一个临时的 filenames 列表，保存上传后的文件名到 session 中。访问 <http://localhost:5000/multi-upload> 打开多文 件上传示例，单击按钮后可以选择多个文件，当上传的文件通过验证时，程序会重定向到 show_images 视图，这个视图返回的 uploaded.html 模板中将从 session 获取所有文件名，渲染出所有上传后的图片。

8. 顺便说一句，在新版本的 Flask-WTF 发布后，你就可以使用和单文件上传相同的方式处理表单。

9. 比如，我们可以使用 Flask-WTF 提供的 MultipleFileField 来创建提供 Flask 支持的多文件上传字段，使用相应的验证器对文件进行验证。在视图函数中，我们则可以继续使用 form.validate_on_submit() 来验证表单，并通过 form.photo.data 来获取字段的数据——包含所有上传文件对象(werkzeug.datastructures.FileStorage)的列表。

### 4.5.5 使用 Flask-CKEditor 集成富文本编辑器

1. 富文本编辑器即 WYSIWYG(What You See Is What You Get，所见即所得)编辑器，类似于我们经常使用的文本编辑软件。它提供一系列按钮和下拉列表来为文本设置格式，编辑状态的文本样式即最终呈现出来的样式。在 Web 程序中，这种编辑器也称为 HTML 富文本编辑器，因为它使用 HTML 标签来为文本定义样式。

2. [CKEditor](http://ckeditor.com/)是一个开源的富文本编辑器，它包含丰富的配置选项，而且有大量第三方插件支持。扩展 Flask-CKEditor 简化了在 Flask 程序中使用 CKEditor 的过程，我们将使用它来集成 CKEditor。首先使用 Pipenv 安装：

   ```python
   pipenv install flask-ckeditor
   ```

3. 然后实例化 Flask-CKEditor 提供的 CKEditor 类，传入程序实例：

   ```python
   from flask_ckeditor import CKEditor

   ckeditor = CKEditor(app)
   ```

#### 4.5.5.1 配置富文本编辑器

1. Flask-CKEditor 提供了许多配置变量来对编辑器进行设置，常用的配置及其说明如下表所示。

   <center><b>Flask-CKEditor 常用配置</b></center>

   |        配置键        |   默认值   |                       说明                        |
   | :------------------: | :--------: | :-----------------------------------------------: |
   | CKEDITOR_SERVE_LOCAL |   False    |          设为 True 会使用内置的本地资源           |
   |  CKEDITOR_PKG_TYPE   | 'standard' | CKEditor 包类型，可选值为 basic、standard 和 full |
   |  CKEDITOR_LANGUAGE   |     ''     |        界面语言，传入 ISO 639 格式的语言码        |
   |   CKEDITOR_HEIGHT    |     ''     |                    编辑器高度                     |
   |    CKEDITOR_WIDTH    |     ''     |                    编辑器宽度                     |

2. 完整的可用配置列表见 Flask-CKEditor 文档的[配置部分](<https://flask-ckeditor.readthedocs.io/en/latest/configuration.html>)

3. 在示例程序中，为了方便开发，使用了内置的本地资源：

   ```python
   app.config['CKEDITOR_SERVE_LOCAL'] = True
   ```

4. CKEDITOR_SERVE_LOCAL 和 CKEDITOR_PKG_TYPE 配置变量仅限于使用 Flask-CKEditor 提供的方法加载资源时有效，手动引入资源时可以忽略。

5. 配置变量 CKEDITOR_LANGUAGE 用来固定界面的显示语言(简体中文和繁体中文对应的配置分别为 zh-cn 和 zh)，如果不设置，默认 CKEditor 会自动探测用户浏览器的语言偏好，然后匹配对应的语言，匹配失败则默认使用英文。

6. Flask-CKEditor 内置了对常用第三方 CKEditor 插件的支持，你可以轻松地为编辑器添加图片上传与插入、插入语法高亮代码片段、Markdown 编辑模式等功能，具体可以访问 [Flask-CKEditor 文档的插件集成部分](https://flask-ckeditor.readthedocs.io/en/latest/plugins.html)。

7. 要使用这些功能，需要在 CKEditor 包中安装对应的插件，Flask-CKEditor 内置的资源已经包含了这些插件，你可以通过 [Flask-CKEditor 提供的示例程序](https://github.com/greyli/flask-ckeditor/tree/master/examples)来了解这些功能的具体实现。

#### 4.5.5.2 渲染富文本编辑器

1. 富文本编辑器在 HTML 中通过文本区域字段表示，即 `<textarea> </textarea>`。Flask-CKEditor 通过包装 WTForms 提供的 TextAreaField 字段类型实现了一个 CKEditorField 字段类，我们使用它来构建富文本编辑框字段。如下代码中的 RichTextForm 表单包含了一个标题字段和一个正文字段。

   <center><b>form/forms.py：文章表单</b></center>

   ```python
   from flask_wtf import FlaskForm
   from wtforms import StringField, SubmitField
   from wtforms.validators import DataRequired, Length
   from flask_ckeditor import CKEditorField # 从 flask_ckeditor 包导入

   class RichTextForm(FlaskForm):
       title = StringField('Title', validators=[DataRequired(), Length(1, 50)])
       body = CKEditorField('Body', validators=[DataRequired()])
       submit = SubmitField('Publish')
   ```

2. 文章正文字段(body)使用的 CKEditorField 字段类型从 FlaskCKEditor 导入。我们可以像其他字段一样定义标签、验证器和默认值。在使用上，这个字段和 WTForms 内置的其他字段完全相同。比如，在提交表单时，同样使用 data 属性获取数据。

3. 在模板中，渲染这个 body 字段的方式和其他字段也完全相同，在示例程序中，我们在模板 ckeditor.html 渲染了这个表单，如下代码所示。

   <center><b>form/templates/ckeditor.html：渲染包含 CKEditor 编辑器的表单</b></center>

   ```jinja2
   {% extends 'base.html' %}
   {% from 'macros.html' import form_field %}
   {% block content %}
   <h1>Integrate CKEditor with Flask-CKEditor</h1>
   <form method="post">
       {{ form.csrf_token }}
       {{ form_field(form.title) }}
       {{ form_field(form.body) }}
       {{ form.submit }}
   </form>
   {% endblock %}

   {% block scripts %}
   {{ super() }}
   {{ ckeditor.load() }}
   {% endblock %}
   ```

4. 渲染 CKEditor 编辑器需要加载相应的 JavaScript 脚本。在开发时，为了方便开发，可以使用 Flask-CKEditor 在模板中提供的 ckeditor.load() 方法加载资源，它默认从 CDN 加载资源，将 CKEDITOR_SERVE_LOCAL 设为 True 会使用扩展内置的本地资源，内置的本地资源包含了几个常用的插件和语言包

5. ckeditor.load() 方法支持通过 pkg_type 参数传入包类型，这会覆盖配置 CKEDITOR_PKG_TYPE 的值，额外的 version 参数可以设置从 CDN 加载的 CKEditor 版本。

6. 作为替代，你可以访问 [CKEditor 官网提供的构建工具](https://ckeditor.com/cke4/builder)构建自己的 CKEditor 包，下载后放到 static 目录下，然后在需要显示文本编辑器的模板中加载包目录下的 ckeditor.js 文件，替换掉 ckeditor.load() 调用。

7. 如果你使用配置变量设置了编辑器的高度、宽度和语言或是其他插件配置，需要使用 ckeditor.config() 方法加载配置，传入对应表单字段的 name 属性值，即对应表单类属性名。这个方法需要在加载 CKEditor 资源后调用：

   ```python
   {{ ckeditor.config(name='body') }}
   ```

8. 为了支持为不同页面上的编辑器字段或单个页面上的多个编辑器字段使用不同的配置，大多数配置键都可以通过相应的关键字在 ckeditor.config() 方法中传入，比如 language、height、width 等，这些参数会覆盖对应的全局配置。另外，Flask-CKEditor 也允许你传入自定义配置字符串，更多详情可访问 [Flask-CKEditor 文档的配置部分](https://flask-ckeditor.readthedocs.io/configuration.html)

9. 如果你不使用 Flask-WTF/WTForms，Flask-CKEditor 还提供了一个在模板中直接创建文本编辑器字段的 ckeditor.create() 方法，具体用法参考相关文档。

### 4.5.6 单个表单多个提交按钮

1. 在某些情况下，我们可能需要为一个表单添加多个提交按钮。比如在创建文章的表单中添加发布新文章和保存草稿的按钮。当用户提交表单时，我们需要在视图函数中根据按下的按钮来做出不同的处理。如下代码创建了一个这样的表单，其中 save 表示保存草稿按钮，publish 表示发布按钮，正文字段使用 TextAreaField 字段。

   <center><b>form/forms.py：包含两个提交按钮的表单</b></center>

   ```python
   class NewPostForm(FlaskForm):
       title = StringField('Title', validators=[DataRequired(), Length(1, 50)])
       body = TextAreaField('Body', validators=[DataRequired()])
       save = SubmitField('Save') # 保存按钮
       publish = SubmitField('Publish') # 发布按钮
   ```

2. 当表单数据通过 POST 请求提交时，Flask 会把表单数据解析到 request.form 字典。如果表单中有两个提交字段，那么只有被单击的提交字段才会出现在这个字典中。

3. 当我们对表单类实例或特定的字段属性调用 data 属性时，WTForms 会对数据做进一步处理。对于提交字段的值，它会将其转换为布尔值：被单击的提交字段的值将是 True ，未被单击的值则是 False 。

4. 基于这个机制，我们可以通过提交按钮字段的值来判断当前被单击的按钮，如下代码所示。

   <center><b>form/app.py：判断被单击的提交按钮</b></center>

   ```python
   @app.route('/two-submits', methods=['GET', 'POST'])
   def two_submits():
       form = NewPostForm()
       if form.validate_on_submit():
           if form.save.data: # 保存按钮被单击
               # save it...
               flash('You click the "Save" button.')
           elif form.publish.data: # 发布按钮被单击
               # publish it...
               flash('You click the "Publish" button.')
           return redirect(url_for('index'))
       return render_template('2submit.html', form=form)
   ```

5. 访问 <http://localhost:5000/two-submits>，当你单击某个按钮时，重定向后的页面的提示信息中会包含你单击的按钮名称。

6. 有些时候，你还想在表单添加非提交按钮。比如，添加一个返回主页的取消按钮。因为这类按钮和表单处理过程无关，最简单的方式是直接在 HTML 模板中手动添加。

### 4.5.7 单个页面多个表单

1. 除了在单个表单上实现多个提交按钮，有时我们还需要在单个页面上创建多个表单。比如，在程序的主页上同时添加登录和注册表单。当在同一个页面上添加多个表单时，我们要解决的一个问题就是在视图函数中判断当前被提交的是哪个表单。

#### 4.5.7.1 单视图处理

1. 创建两个表单，并在模板中分别渲染并不是难事，但是当提交某个表单时，我们就会遇到问题。

2. Flask-WTF 根据请求方法判断表单是否提交，但并不判断是哪个表单被提交，所以我们需要手动判断。基于上一节介绍的内容，我们知道被单击的提交字段最终的 data 属性值是布尔值，即 True 或 False 。

3. 而解析后的表单数据使用 input 字段的 name 属性值作为键匹配字段数据，也就是说，如果两个表单的提交字段名称都是 submit，那么我们也无法判断是哪个表单的提交字段被单击。

4. 解决问题的第一步就是为两个表单的提交字段设置不同的名称，示例程序中的这两个表单如下代码清单所示。

   <center><b>form/forms.py：为两个表单设置不同的提交字段名称</b></center>

   ```python
   class SigninForm(FlaskForm):
       username = StringField('Username', validators=[DataRequired(), Length(1, 20)])
       password = PasswordField('Password', validators=[DataRequired(), Length(8, 128)])
       submit1 = SubmitField('Sign in')

   class RegisterForm(FlaskForm):
       username = StringField('Username', validators=[DataRequired(), Length(1, 20)])
       email = StringField('Email', validators=[DataRequired(), Email(), Length(1, 254)])
       password = PasswordField('Password', validators=[DataRequired(), Length(8, 128)])
       submit2 = SubmitField('Register')
   ```

5. 在视图函数中，我们分别实例化这两个表单，根据提交字段的值来区分被提交的表单，如下代码所示。

   <center><b>form/app.py：在视图函数中处理多个表单</b></center>

   ```python
   @app.route('/multi-form', methods=['GET', 'POST'])
   def multi_form():
       signin_form = SigninForm()
       register_form = RegisterForm()
       if signin_form.submit1.data and signin_form.validate():
           username = signin_form.username.data
           flash('%s, you just submit the Signin Form.' % username)
           return redirect(url_for('index'))

       if register_form.submit2.data and register_form.validate():
           username = register_form.username.data
           flash('%s, you just submit the Register Form.' % username)
           return redirect(url_for('index'))

       return render_template('2form.html', signin_form=signin_form, register_form=register_form)
   ```

6. 在视图函数中，我们为两个表单添加了各自的 if 判断，在这两个 if 语句的内部，我们分别执行各自的代码逻辑。

7. 以登录表单(SigninForm)的 if 判断为例，如果 signin_form.submit1.data 的值为 True ，那就说明用户提交了登录表单，这时我们手动调用  signin_form.validate() 对这个表单进行验证。

8. 这两个表单类实例通过不同的变量名称传入模板，以便在模板中相应渲染对应的表单字段，如下所示：

   ```python
   ...
   <form method="post">
       {{ signin_form.csrf_token }}
       {{ form_field(signin_form.username) }}
       {{ form_field(signin_form.password) }}
       {{ signin_form.submit1 }}
   </form>
   <h2>Register Form</h2>
   <form method="post">
       {{ register_form.csrf_token }}
       {{ form_field(register_form.username) }}
       {{ form_field(register_form.email) }}
       {{ form_field(register_form.password) }}
       {{ register_form.submit2 }}
   </form>
   ...
   ```

9. 访问 <http://localhost:5000/multi-form> 打开示例页面，当提交某个表单后，你会在重定向后的页面的提示消息里看到提交表单的名称。

#### 4.5.7.2 多视图处理

1. 除了通过提交按钮判断，更简洁的方法是通过分离表单的渲染和验证实现。这时表单的提交字段可以使用同一个名称，在视图函数中处理表单时也只需使用我们熟悉的 form.validate_on_submit() 方法。

2. 在介绍表单处理时，我们在同一个视图函数内处理两类工作：渲染包含表单的模板(GET 请求)、处理表单请求(POST 请求)。如果你想解耦这部分功能，那么也可以分离成两个视图函数处理。当处理多个表单时，我们可以把表单的渲染在单独的视图函数中处理，如下所示：

   ```python
   @app.route('/multi-form-multi-view')
   def multi_form_multi_view():
       signin_form = SigninForm2()
       register_form = RegisterForm2()
       return render_template('2form2view.html', signin_form=signin_form, register_form=register_form)
   ```

3. 这个视图只负责处理 GET 请求，实例化两个表单类并渲染模板。另外我们再为每一个表单单独创建一个视图函数来处理验证工作。处理表单提交请求的视图仅监听 POST 请求，如下代码所示。

   <center><b>form/app.py：使用单独的视图函数处理表单提交的 POST 请求</b></center>

   ```python
   @app.route('/handle-signin', methods=['POST']) # 仅传入 POST 到 methods 中
   def handle_signin():
       signin_form = SigninForm2()
       register_form = RegisterForm2()
       if signin_form.validate_on_submit():
           username = signin_form.username.data
           flash('%s, you just submit the Signin Form.' % username)
           return redirect(url_for('index'))
       return render_template('2form2view.html', signin_form=signin_form, register_form=register_form)

   @app.route('/handle-register', methods=['POST'])
   def handle_register():
       signin_form = SigninForm2()
       register_form = RegisterForm2()
       if register_form.validate_on_submit():
           username = register_form.username.data
           flash('%s, you just submit the Register Form.' % username)
           return redirect(url_for('index'))
       return render_template('2form2view.html', signin_form=signin_form, register_form=register_form)
   ```

4. 在 HTML 中，表单提交请求的目标 URL 通过 action 属性设置。为了让表单提交时将请求发送到对应的URL，我们需要设置 action 属性，如下所示：

   ```python
   ...
   <h2>Login Form</h2>
   <form method="post" action="{{ url_for('handle_signin') }}">
   ...
   </form> <h2>Register Form</h2>
   <form method="post" action="{{ url_for('handle_register') }}">
   ...
   </form>
   ...
   ```

5. 虽然现在可以正常工作，但是这种方法有一个显著的缺点。如果验证未通过，你需要将错误消息的 form.errors 字典传入模板中。在处理表单的视图中传入表单错误信息，就意味着需要再次渲染模板，但是如果视图函数中还涉及大量要传入模板的变量操作，那么这种方式会带来大量的重复。

6. 对于这个问题，一般的解决方式是通过其他方式传递错误消息，然后统一重定向到渲染表单页面的视图。比如，使用 flash() 函数迭代 form.errors 字典发送错误消息(这个字典包含字段名称与错误消息列表的映射)，然后重定向到用来渲染表单的 multi_form_multi_view 视图。下面是一个使用 flash() 函数来发送表单错误消息的便利函数：

   ```python
   def flash_errors(form):
       for field, errors in form.errors.items():
           for error in errors:
               flash(u"Error in the %s field - %s" % ( getattr(form, field).label.text, error ))
   ```

7. 如果你希望像往常一样在表单字段下渲染错误消息，可以直接将错误消息字典 form.errors 存储到 session 中，然后重定向到用来渲染表单的 multi_form_multi_view 视图。在模板中渲染表单字段错误时添加一个额外的判断，从 session 中获取并迭代错误消息。

## 4.6 本章小结

1. 除了普通的表单定义，WTForms 还提供了很多高级功能，比如自定义表单字段、动态表单等，你可以访问 WTForms 的官方文档学习更多内容。
2. 下一章，我们会学习数据库知识，为 Flask 程序添加数据库支持，那时我们就可以把表单数据存储到数据库里了。
