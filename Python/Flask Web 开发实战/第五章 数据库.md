# 数据库

## 5.1 背景

1. 数据库是大多数动态 Web 程序的基础设施，只要你想把数据存储下来，就离不开数据库。我们这里提及的数据库(Database)指的是由存储数据的单个或多个文件组成的集合，它是一种容器，可以类比为文件柜。

2. 而人们通常使用数据库来表示操作数据库的软件，这类管理数据库 的软件被称为数据库管理系统(DBMS，Database Management System)，常见的 DBMS 有 MySQL、PostgreSQL、SQLite、MongoDB 等。为了便于理解，我们可以把数据库看作一个大仓库，仓库里有一些负责搬运货物(数据)的机器人，而 DBMS 就是操控机器人搬运货物的程序。

3. 这一章我们来学习如何给 Flask 程序添加数据库支持。具体来说，是学习如何在 Python 中使用这些 DBMS 来对数据库进行管理和操作。

4. 本章新涉及的 Python 库如下所示：

   - SQLAlchemy（1.2.7）
     - [主页](http://www.sqlalchemy.org/)
     - [源码](https://github.com/zzzeek/sqlalchemy)
     - [文档](http://docs.sqlalchemy.org/en/latest/)
   - Flask-SQLAlchemy(2.3.2)
     - [主页](https://github.com/mitsuhiko/flask-sqlalchemy)
     - [文档](http://flask-sqlalchemy.pocoo.org/2.3/)
   - Alembic(0.9.9)
     - [主页](https://bitbucket.org/zzzeek/alembic)
     - [文档](http://alembic.zzzcomputing.com/en/latest/)
   - Flask-Migrate(2.1.1)
     - [主页](https://github.com/miguelgrinberg/Flask-Migrate)
     - [文档](https://flask-migrate.readthedocs.io/en/latest/)

5. 本章的示例程序在 helloflask/demos/database 目录下，确保当前目录在 helloflask/demos/database 下并激活了虚拟环境，然后执行 flask run 命令运行程序：

   ```bash
   cd demos/database
   flask run
   ```

6. 因为所有示例程序的 CSS 文件名称、JavaScript 文件名称以及 Favicon 文件名称均相同，为了避免浏览器对不同示例程序中同名的文件进行缓存，请在第一次运行新的示例程序后按下 Crtl+F5 或 Shift+F5 清除缓存。

## 5.2 数据库的分类

1. 数据库一般分为两种，SQL(Structured Query Language，结构化查询语言)数据库和 NoSQL(Not Only SQL，泛指非关系型)数据库。

### 5.2.1 SQL

1. SQL 数据库指关系型数据库，常用的 SQL DBMS 主要包括 SQL Server、Oracle、MySQL、PostgreSQL、SQLite 等。关系型数据库使用表来定义数据对象，不同的表之间使用关系连接。下表是一个身份信息表的示例。

   <center><b>关系型数据库示例</b></center>

   |  id  | name |  sex   | occupation |
   | :--: | :--: | :----: | :--------: |
   |  1   | Nick |  Male  | Journalist |
   |  2   | Amy  | Female |   Writer   |

2. 在 SQL 数据库中，每一行代表一条记录(record)，每条记录又由不同的列(column)组成。在存储数据前，需要预先定义表模式(schema)，以定义表的结构并限定列的输入数据类型。

3. 为了避免在措辞上引起误解，我们先了解几个基本概念：

   - 表(table)：存储数据的特定结构。
   - 模式(schema)：定义表的结构信息。
   - 列/字段(column/field)：表中的列，存储一系列特定的数据，列组成表。
   - 行/记录(row/record)：表中的行，代表一条记录。
   - 标量(scalar)：指的是单一数据，与之相对的是集合(collection)

### 5.2.2　NoSQL

1. 最常用的两种 NoSQL 数据库如下所示：

   - 文档存储(document store)

     - 文档存储是 NoSQL 数据库中最流行的种类，它可以作为主数据库使用。文档存储使用的文档类似 SQL 数据库中的记录，文档使用类 JSON 格式来表示数据。常见的文档存储 DBMS 有 MongoDB、CouchDB 等。

     - 下表的身份信息表中的第一条记录使用文档可以表示为：

       ```json
       {
           id: 1,
           name: "Nick",
           sex: "Male",
           occupation: "Journalist"
       }
       ```

   - 键值对存储(key-value store)

     - 键值对存储在形态上类似 Python 中的字典，通过键来存取数据，在读取上非常快，通常用来存储临时内容，作为缓存使用。
     - 常见的键值对 DBMS 有 Redis、Riak 等，其中 Redis 不仅可以管理键值对数据库，还可以作为缓存后端(cache backend)和消息代理(message broker)。
     - 另外，还有列存储(column store，又被称为宽列式存储)、图存储(graph store)等类型的 NoSQL 数据库，这里不再展开介绍。

### 5.2.3　如何选择？

1. NoSQL 数据库不需要定义表和列等结构，也不限定存储的数据格式，在存储方式上比较灵活，在特定的场景下效率更高。
2. SQL 数据库稍显复杂，但不容易出错，能够适应大部分的应用场景。这两种数据库都 各有优势，也各有擅长的领域。两者并不是对立的，我们需要根据使用场景选择适合的数据库类型。大型项目通常会同时需要多种数据库，比如使用 MySQL 作为主数据库存储用户资料和文章，使用 Redis(键值对型数据库)缓存数据，使用 MongoDB(文档型数据库)存储实时消息。
3. 大多数情况下，SQL 数据库都能满足你的需求。为了便于开发和测试，本书中的示例程序都使用 SQLite 作为 DBMS 。对于大型程序，在部署程序前，你需要根据程序的特点来改用更健壮的 DBMS 。

## 5.3 ORM 魔法

1. 在 Web 应用里使用原生 SQL 语句操作数据库主要存在下面两类问题：

   - 手动编写SQL语句比较乏味，而且视图函数中加入太多 SQL 语句会降低代码的易读性。另外还会容易出现安全问题，比如 SQL 注入。

   - 常见的开发模式是在开发时使用简单的 SQLite ，而在部署时切换到 MySQL 等更健壮的 DBMS 。但是对于不同的 DBMS ，我们需要使用不同的 Python 接口库，这让 DBMS 的切换变得不太容易。

2. 尽管使用 ORM 可以避免 SQL 注入问题，但你仍然需要对传入的查询参数进行验证。另外，在执行原生 SQL 语句时也要注意避免使用字符串拼接或字符串格式化的方式传入参数。

3. 使用 ORM 可以很大程度上解决这些问题。它会自动帮你处理查询参数的转义，尽可能地避免 SQL 注入的发生。另外，它为不同的 DBMS 提供统一的接口，让切换工作变得非常简单。ORM 扮演翻译的角色，能够将我们的 Python 语言转换为 DBMS 能够读懂的 SQL 指令，让我们能够使用 Python 来操控数据库。

4. 尽管 ORM 非常方便，但如果你对 SQL 相当熟悉，那么自己编写 SQL 代码可以获得更大的灵活性和性能优势。就像是使用 IDE 一样，ORM 对初学者来说非常方便，但进阶以后你也许会想要自己掌控一切。

5. ORM 把底层的 SQL 数据实体转化成高层的 Python 对象，这样一来，你甚至不需要了解 SQL ，只需要通过 Python 代码即可完成数据库操作，ORM 主要实现了三层映射关系：

   - 表 → Python类。
   - 字段(列) → 类属性。
   - 记录(行) → 类实例。

6. 比如，我们要创建一个 contacts 表来存储留言，其中包含用户名称和电话号码两个字段。在 SQL 中，下面的代码用来创建这个表：

   ```sql
   CREATE TABLE contacts( name varchar(100) NOT NULL, phone_number varchar(32), );
   ```

7. 如果使用 ORM ，我们可以使用类似下面的 Python 类来定义这个表：

   ```python
   from foo_orm import Model, Column, String

   class Contact(Model):
       __tablename__ = 'contacts'
       name = Column(String(100), nullable=False)
       phone_number = Column(String(32))
   ```

8. 要向表中插入一条记录，需要使用下面的 SQL 语句：

   ```sql
   INSERT INTO contacts(name, phone_number) VALUES('Grey Li', '12345678');
   ```

9. 使用 ORM 则只需要创建一个 Contact 类的实例，传入对应的参数表示各个列的数据即可。下面的代码和使用上面的 SQL 语句效果相同：

   ```python
   contact = Contact(name='Grey Li', phone_number='12345678')
   ```

10. 除了便于使用，ORM 还有下面这些优点：

    - 灵活性好。你既能使用高层对象来操作数据库，又支持执行原生 SQL 语句。
    - 提升效率。从高层对象转换成原生 SQL 会牺牲一些性能，但这微不足道的性能牺牲换取的是巨大的效率提升。

    - 可移植性好。ORM 通常支持多种 DBMS，包括 MySQL、 PostgreSQL、Oracle、SQLite 等。你可以随意更换 DBMS，只需要稍微改动少量配置。

11. 使用 Python 实现的 ORM 有 SQLAlchemy、Peewee、PonyORM 等。其中 SQLAlchemy 是 Python 社区使用最广泛的 ORM 之一，我们将介绍如何在 Flask 程序中使用它。

12. SQL-Alchemy，直译过来就是 SQL 炼金术，下一节我们会见识到 SQLAlchemy 的神奇力量。

## 5.4　使用Flask-SQLAlchemy管理数据库

1. 扩展 Flask-SQLAlchemy 集成了 SQLAlchemy，它简化了连接数据库服务器、管理数据库操作会话等各类工作，让 Flask 中的数据处理体验变得更加轻松。首先使用 Pipenv 安装 Flask-SQLAlchemy 及其依赖(主要是 SQLAlchemy)：

   ```bash
   pipenv install flask-sqlalchemy
   ```

2. 下面在示例程序中实例化 Flask-SQLAlchemy 提供的 SQLAlchemy 类，传入程序实例 app，以完成扩展的初始化：

   ```python
   from flask import Flask
   from flask_sqlalchemy import SQLAlchemy

   app = Flask(__name__)
   db = SQLAlchemy(app)
   ```

3. 为了便于使用，我们把实例化扩展类的对象命名为 db 。这个 db 对象代表我们的数据库，它可以使用 Flask-SQLAlchemy 提供的所有功能。

### 5.4.1 连接数据库服务器

1. DBMS 通常会提供数据库服务器运行在操作系统中。要连接数据库服务器，首先要为我们的程序指定数据库 URI(Uniform Resource Identifier，统一资源标识符)。数据库 URI 是一串包含各种属性的字符串，其中包含了各种用于连接数据库的信息。

2. URI 代表统一资源标识符，是用来标示资源的一组字符串。URL 是它的子集。在大多数情况下，这两者可以交替使用。

   |      DBMS       |                             URI                              |
   | :-------------: | :----------------------------------------------------------: |
   |   PostgreSQL    |       postgresql://username:password@host/databasename       |
   |      MySQL      |         mysql://username:password@host/databasename          |
   |     Oracle      |         oracle://username:password@host:port/sidname         |
   |  SQLite(UNIX)   |              sqlite:////absolute/path/to/foo.db              |
   | SQLite(Windows) | `sqlite:////absolute\\path\\to\\foo.db` 或 r'sqlite:////absolute\path\to\foo.db' |
   | SQLite(内存型)  |              sqlite://// 或 sqlite:////:memory:              |

3. 在 Flask-SQLAlchemy 中，数据库的URI通过配置变量 SQLALCHEMY_DATABASE_URI 设置，默认为 SQLite 内存型数据库(sqlite:///:memory:)

4. SQLite 是基于文件的 DBMS，不需要设置数据库服务器，只需要指定数据库文件的绝对路径。我们使用 app.root_path 来定位数据库文件的路径，并将数据库文件命名为 data.db ，如下代码所示。

   ```python
   app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL', 'sqlite:////absolute/path/to/data.db')
   ```

5. 在生产环境下更换到其他类型的 DBMS 时，数据库 URL 会包含敏感信息，所以这里优先从环境变量 DATABASE_URL 获取(注意这里为了便于理解使用了 URL，而不是 URI )。

6. SQLite 的数据库 URI 在 Linux 或 MacOS 系统下的斜线数量是 4 个；在 Windows 系统下的 URI 中的斜线数量为 3 个。内存型数据库的斜线固定为 3个。

7. SQLite 数据库文件名不限定后缀，常用的命名方式有 foo.sqlite ，foo.db，或是注明 SQLite 版本的 foo.sqlite3 。

8. 设置好数据库 URI 后，在 Python Shell 中导入并查看 db 对象会获得下面的输出：

   ```python
   >>> from app import db
   >>> db
   <SQLAlchemy engine=sqlite:///Path/to/your/data.db>
   ```

9. 安装并初始化 Flask-SQLAlchemy 后，启动程序时会看到命令行下有一行警告信息。这是因为 Flask-SQLAlchemy 建议你设置 SQLALCHEMY_TRACK_MODIFICATIONS 配置变量，这个配置变量决定是否追踪对象的修改，这用于 Flask-SQLAlchemy 的事件通知系统。这个配置键的默认值为 None ，如果没有特殊需要，我们可以把它设为 False 来关闭警告信息：

   ```python
   app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
   ```

10. Flask-SQLAlchemy 计划在 3.0 版本默认将这个配置键设为 False ，目前最新版本为 2.3.2 。

### 5.4.2 定义数据库模型

1. 用来映射到数据库表的 Python 类通常被称为数据库模型(model)，一个数据库模型类对应数据库中的一个表。定义模型即使用 Python 类定义表模式，并声明映射关系。

2. 所有的模型类都需要继承 Flask-SQLAlchemy 提供的 db.Model 基类。本章的示例程序是一个笔记程序，笔记保存到数据库中，你可以通过程序查询、添加、更新和删除笔记。在下面代码中，我们定义了一个 Note 模型类，用来存储笔记。

   <center><b>app.py：定义 Note 模型</b></center>

   ```python
   class Note(db.Model):
       id = db.Column(db.Integer, primary_key=True)
       body = db.Column(db.Text)
   ```

3. 在上面的模型类中，表的字段(列)由 db.Column 类的实例表示，字段的类型通过 Column 类构造方法的第一个参数传入。

4. 在这个模型中，我们创建了一个类型为 db.Integer 的 id 字段和类型为 db.Text 的 body 列，分别存储整型和文本。常用的 SQLAlchemy 字段类型如下所示。

   <center><b>SQLAlchemy 常用的字段类型</b></center>

   |    字段     |                       说明                       |
   | :---------: | :----------------------------------------------: |
   |   Integer   |                       整型                       |
   |   String    |   字符串。可选参数 length 可以用来设置最大长度   |
   |    Text     |               较长的 Unicode 文本                |
   |    Date     |     日期，存储 Python 的 datetime.date 对象      |
   |    Time     |     时间，存储 Python 的 datetime.time 对象      |
   |  DateTime   |     时间和日期，存储 Python 的 datetime 对象     |
   |  Interval   | 时间间隔，存储 Python 的 datetime.timedelta 对象 |
   |    Float    |                      浮点数                      |
   |   Boolean   |                      布尔值                      |
   | PickleType  |          存储 Pickle 列化的 Python 对象          |
   | LargeBinary |                存储任意二进制数据                |

5. 字段类型一般直接声明即可，如果需要传入参数，你也可以添加括号。对于类似 String 的字符串列，有些数据库会要求限定长度，因此最好为其指定长度。虽然使用 Text 类型可以存储相对灵活的变长文本，但从性能上考虑，我们仅在必须的情况下使用 Text 类型，比如用户发表的文章和评论等不限长度的内容。

6. 一般情况下，字段的长度是由程序设计者自定的。尽管如此，也有一些既定的约束标准，比如姓名(英语)的长度一般不超过 70 个字符，中文名一般不超过 20 个字符，电子邮件地址的长度不超过 254 个字符，

7. 虽然各主流浏览器支持长达 2048 个字符的 URL ，但在网站中用户资料设 置的限度一般为 255 。尽管如此，对于超过一定长度的 Email 和 URL ，比如 20 个字符，会在显示时添加省略号的形式。显示的用户名(username)允许重复，通常要短一些，以不超过 36 个字符为佳。当然，在程序中，你可以根据需要来自由设定这些限制值。

8. 当你在数据库模型类中限制了字段的长度后，在接收对应数据的表单类字段里，也需要使用 Length 验证器来验证用户的输入数据。

9. 默认情况下，Flask-SQLAlchemy 会根据模型类的名称生成一个表名称，生成规则如下：

   ```text
   Message --> message # 单个单词转换为小写
   FooBar --> foo_bar # 多个单词转换为小写并使用下划线分隔
   ```

10. Note 类对应的表名称即 note 。如果你想自己指定表名称，可以通过 定义 `__tablename__` 属性来实现。字段名默认为类属性名，你也可以通过字段类构造方法的第一个参数指定，或使用关键字 name 。根据我们定义的 Note 模型类，最终将生成一个 note 表，表中包含 id 和 body 字段。

11. 除了 name 参数，实例化字段类时常用的字段参数如下所示。

    <center><b>常用的 SQLAlchemy 字段参数</b></center>

    |   参数名    |                           说明                           |
    | :---------: | :------------------------------------------------------: |
    | primary_key |               如果设为 True，该字段为主键                |
    |   unique    |          如果设为 True，该字段不允许出现重复值           |
    |    index    |     如果设为 True，为该字段创建索引，以提高查询效率      |
    |  nullable   | 确定字段值为可否为空，值为 True 或 False， 默认值为 True |
    |   default   |                     为字段设置默认值                     |

12. 不需要在所有列都建立索引。一般来说，取值可能性多(比如姓名)的列，以及经常被用来作为排序参照的列(比如时间戳)更适合建立索引。

13. 在实例化字段类时，通过把参数 primary_key 设为 True 可以将其定义为主键。在我们定义的 Note 类中，id 字段即表的主键(primary key)。 主键是每一条记录(行)独一无二的标识，也是模型类中必须定义的字段，一般命名为 id 或 pk 。

### 5.4.3　创建数据库和表

1. 如果把数据库(文件)看作一个仓库，为了方便取用，我们需要把货物按照类型分别放置在不同货架上，这些货架就是数据库中的表。创建模型类后，我们需要手动创建数据库和对应的表，也就是我们常说的建库和建表。这通过对我们的db对象调用 create_all() 方法实现：

   ```python
   $ flask shell

   >>> from app import db

   >>> db.create_all()
   ```

2. 如果你将模型类定义在单独的模块中，那么必须在调用 db.create_all() 方法前导入相应模块，以便让 SQLAlchemy 获取模型类被创建时生成的表信息，进而正确生成数据表。

3. 通过下面的方式可以查看模型对应的 SQL 模式(建表语句)：

   ```python
   >>> from sqlalchemy.schema import CreateTable
   >>> print(CreateTable(Note.__table__))
   CREATE TABLE note (id INTEGER NOT NULL, body TEXT, PRIMARY KEY (id) )
   ```

4. 数据库和表一旦创建后，之后对模型的改动不会自动作用到实际的表中。比如，在模型类中添加或删除字段，修改字段的名称和类型，这时再次调用 create_all() 也不会更新表结构。如果要使改动生效，最简单的方式是调用 db.drop_all() 方法删除数据库和表，然后再调用 db.create_all() 方法创建，后面会具体介绍。

5. 我们也可以自己实现一个自定义 flask 命令完成这个工作，如下所示。

   <center><b>demos/database/app.py：用于创建数据库和表的 flask 命令</b></center>

   ```python
   import click
   ...

   @app.cli.command()
   def initdb():
       db.create_all()
       click.echo('Initialized database.')
   ```

6. 在命令行下输入 flask initdb 即可创建数据库和表：

   ```python
   $ flask initdb
   Initialized database.
   ```

7. 对于示例程序来说，这会在 database 目录下创建一个 data.db 文件。

8. 在开发程序或是部署后，我们经常需要在 Python Shell 中手动操作数据库(生产环境需注意备份)，对于一次性操作，直接处理即可。对于需要重用的操作，我们可以编写成 Flask 命令、函数或是模型类的类方法。

## 5.5　数据库操作

1. 现在我们创建了模型，也生成了数据库和表，是时候来学习常用的数据库操作了。数据库操作主要是 CRUD ，即 Create(创建)、 Read(读取/查询)、Update(更新)和 Delete(删除)。
2. SQLAlchemy 使用数据库会话来管理数据库操作，这里的数据库会话也称为事务(transaction)。Flask-SQLAlchemy 自动帮我们创建会话，可以通过 db.session 属性获取。
3. SQLAlchemy 中的数据库会话对象和我们在前面介绍的 Flask 中的 session 无关。
4. 数据库中的会话代表一个临时存储区，你对数据库做出的改动都会存放在这里。你可以调用 add() 方法将新创建的对象添加到数据库会话中，或是对会话中的对象进行更新。只有当你对数据库会话对象调用 commit() 方法时，改动才被提交到数据库，这确保了数据提交的一致性。
5. 另外，数据库会话也支持回滚操作。当你对会话调用 rollback() 方法时，添加到会话中且未提交的改动都将被撤销。

### 5.5.1 CRUD

1. 这一节我们会在 Python Shell 中演示 CRUD 操作。默认情况下， Flask-SQLAlchemy(>=2.3.0 版本)会自动为模型类生成一个 `__repr__()` 方法。

2. 当在 Python Shell 中调用模型的对象时， `__repr__()` 方法会返回一条类似 "<模型类名主键值>" 的字符串，比如 `<Note 2>`。为了便于实际操作测试，示例程序中，所有的模型类都重新定义了 `__repr__()` 方法，返回一些更有用的信息，比如：

   ```python
   class Note(db.Model):
       ...

       def __repr__(self):
           return '<Note %r>' % self.body
   ```

3. 在实际开发中，这并不是必须的。另外，为了节省篇幅，后面的模型类定义不会给出这部分代码，具体可到源码仓库中查看。

#### 5.5.1.1 Create

1. 添加一条新记录到数据库主要分为三步：

   - 创建 Python 对象(实例化模型类)作为一条记录。

   - 添加新创建的记录到数据库会话。

   - 提交数据库会话。

2. 下面的示例向数据库中添加了三条留言：

   ```python
   >>> from app import db, Note

   >>> note1 = Note(body='remember Sammy Jankis')

   >>> note2 = Note(body='SHAVE')

   >>> note3 = Note(body='DON'T BELIEVE HIS LIES, HE IS THE ONE, KILL HIM')

   >>> db.session.add(note1)

   >>> db.session.add(note2)

   >>> db.session.add(note3)

   >>> db.session.commit()
   ```

3. 在这个示例中，我们首先从 app 模块导入 db 对象和 Note 类，然后分别创建三个 Note 实例表示三条记录，使用关键字参数传入字段数据。

4. 我们的 Note 类继承自 db.Model 基类，db.Model 基类会为 Note 类提供一个构造函数，接收匹配类属性名称的参数值，并赋值给对应的类属性，所以我们不需要自己在 Note 类中定义构造方法。接着我们调用 add() 方法把这三个 Note 对象添加到会话对象 db.session 中，最后调用 commit() 方法提交会话。

5. 除了依次调用 add() 方法添加多个记录，也可以使用 add_all() 一次添加包含所有记录对象的列表。

6. 你可能注意到了，我们在创建模型类实例的时候并没有定义 id 字段 的数据，这是因为主键由 SQLAlchemy 管理。模型类对象创建后作为临时对象(transient)，当你提交数据库会话后，模型类对象才会转换为 数据库记录写入数据库中，这时模型类对象会自动获得 id 值：

   ```python
   >>> note1.id
   1
   ```

7. Flask-SQLAlchemy 提供了一个 SQLALCHEMY_COMMIT_ON_TEARDOWN 配置变量，将其设为 True 可以设置自动调用 commit() 方法提交数据库会话。因为存在潜在的 Bug，目前已不建议使用，而且未来版本中将移除该配置变量。请避免使用该配置变量，可使用手动调用 db.session.commit() 方法的方式提交数据库会话。

### 5.5.1.2 Read

1. 我们已经知道了如何向数据库里添加记录，那么如何从数据库里取回数据呢？使用模型类提供的 query 属性附加调用各种过滤方法及查询方法可以完成这个任务。

2. 一般来说，一个完整的查询遵循下面的模式：

   ```text
   <模型类>.query.<过滤方法>.<查询方法>
   ```

3. 从某个模型类出发，通过在 query 属性对应的 Query 对象上附加的过滤方法和查询函数对模型类对应的表中的记录进行各种筛选和调整，最终返回包含对应数据库记录数据的模型类实例，对返回的实例调用属性即可获取对应的字段数据。

4. 如果你执行了上面小节里的操作，我们的数据库现在一共会有三条记录，如下表所示。

   <center>Note</center>

   |  id  |                      body                       |
   | :--: | :---------------------------------------------: |
   |  1   |              remember Sammy Jankis              |
   |  2   |                      SHAVE                      |
   |  3   | DON'T BELIEVE HIS LIES, HE IS THE ONE, KILL HIM |

5. SQLAlchemy 提供了许多查询方法用来获取记录，如下表列出了常用的查询方法。

   <center>常用的 SQLAlchemy 查询方法</center>

   |       查询方法        |                             说明                             |
   | :-------------------: | :----------------------------------------------------------: |
   |         all()         |                  返回包含所有查询记录的列表                  |
   |        first()        |        返回查询的第一条记录，如果未找到，则返回 None         |
   |         one()         | 返回第一条记录，且仅允许有一条记录，如果记录数量大于 1 或小于 1，则抛出错误 |
   |      get(ident)       | 传入主键值作为参数，返回指定主键值的记录，如果未找到，则返回 None |
   |        count()        |                      返回查询结果的数量                      |
   |     one_or_none()     |          类似 one()，如果结果数量不为 1，返回 None           |
   |    first_or_404()     |    返回查询的第一条记录，如果未找到，则返回 404 错误响应     |
   |   get_or_404(ident)   | 传入主键值作为参数，返回指定的主键值的记录，如果未找到，则返回 404 错误响应 |
   |      paginate()       |        返回一个 paginate 对象，可以对记录进行分页处理        |
   | with_parent(instance) |    传入模型作为类实例作为参数，返回和这个实例相关联的对象    |

6. 上表中的 first_or_404()、get_or_404() 以及 paginate() 方法是 Flask-SQLAlchemy 附加的查询方法。

7. 下面是对 Note 类进行查询的几个示例。all() 返回所有记录：

   ```python
   >>> Note.query.all()
   [<Note u'remember Sammy Jankis'>, <Note u'SHAVE'>, <Note u'DON'T BELIEVE HIS LIES, HE IS'>
   ```

8. first() 返回第一条记录：

   ```python
   >>> note1 = Note.query.first()
   >>> note1
   <Note u'remember Sammy Jankis'>
   >>> note1.body
   u'remember Sammy Jankis'
   ```

9. get() 返回指定主键值(id 字段)的记录：

   ```python
   >>> note2 = Note.query.get(2)

   >>> note2

   <Note u'SHAVE'>
   ```

10. count() 返回记录的数量：

    ```python
    >>> Note.query.count()
    3
    ```

11. SQLAlchemy 还提供了许多过滤方法，使用这些过滤方法可以获取更精确的查询，比如获取指定字段值的记录。对模型类的 query 属性存储的 Query 对象调用过滤方法将返回一个更精确的 Query 对象(后面我们简称为查询对象)。

12. 因为每个过滤方法都会返回新的查询对象，所以过滤器可以叠加使用。在查询对象上调用前面介绍的查询方法，即可获得一个包含过滤后的记录的列表。常用的查询过滤方法如下表所示。

    | 查询过滤器名称 |                             说明                             |
    | :------------: | :----------------------------------------------------------: |
    |    filter()    |         使用指定的规则过滤记录，返回新产生的查询对象         |
    |  filter_by()   | 使用指定的规则过滤记录(以关键字表达式的形式)，返回新产生的查询对象 |
    |   order_by()   |       根据指定条件对记录进行排序，返回新产生的查询对象       |
    |  limit(limit)  |  使用指定的值限制原查询返回的记录数量，返回新产生的查询对象  |
    |   group_by()   |       根据指定条件对记录进行分组，返回新产生的查询对象       |
    | offset(offset) |      使用指定的值偏移原查询的结果，返回新产生的查询对象      |

13. filter() 方法是最基础的查询方法。它使用指定的规则来过滤记录，下面的示例在数据库里找出了 body 字段值为 "SHAVE" 的记录：

    ```python
    >>> Note.query.filter(Note.body='SHAVE').first()
    <Note u'SHAVE'>
    ```

14. 直接打印查询对象或将其转换为字符串可以查看对应的 SQL 语句：

    ```python
    >>> print(Note.query.filter_by(body='SHAVE'))
    SELECT note.id AS note_id, note.body AS note_body FROM note WHERE note.body = ?
    ```

15. 在 filter() 方法中传入表达式时，除了 "==" 以及表示不等于的 "!=" ，其他常用的查询操作符以及使用示例如下所示：

    - LIKE：

      ```python
      filter(Note.body.like('%foo%'))
      ```

    - IN：

      ```python
      filter(Note.body.in_(['foo', 'bar', 'baz']))
      ```

    - NOT IN：

      ```python
      filter(~Note.body.in_(['foo', 'bar', 'baz']))
      ```

    - AND：

      ```python
      # 使用 and_()
      from sqlalchemy import and_
      filter(and_(Note.body == 'foo', Note.title == 'FooBar'))

      # 或在 filter() 中加入多个表达式，使用逗号分隔
      filter(Note.body == 'foo', Note.title == 'FooBar')

      # 或叠加调用多个 filter()/filter_by() 方法
      filter(Note.body == 'foo').filter(Note.title == 'FooBar')
      ```

    - OR：

      ```python
      from sqlalchemy import or_
      filter(or_(Note.body == 'foo', Note.body == 'bar'))
      ```

16. 和 filter() 方法相比，filter_by() 方法更易于使用。在 filter_by() 方法中，你可以使用关键字表达式来指定过滤规则。更方便的是，你可以在这个过滤器中直接使用字段名称。下面的示例使用 filter_by() 过滤器完成了同样的任务：

    ```python
    >>> Note.query.filter_by(body='SHAVE').first()
    <Note u'SHAVE'>
    ```

17. 其他的查询方法我们会在后面具体应用时详细介绍。

#### 5.5.1.3 Update

1. 更新一条记录非常简单，直接赋值给模型类的字段属性就可以改变字段值，然后调用 commit() 方法提交会话即可。下面的示例改变了一条记录的 body 字段的值：

   ```python
   >>> note = Note.query.get(2)

   >>> note.body u'SHAVE'

   >>> note.body = 'SHAVE LEFT THIGH'

   >>> db.session.commit()
   ```

2. 只有要插入新的记录或要将现有的记录添加到会话中时才需要使用 add() 方法，单纯要更新现有的记录时只需要直接为属性赋新值，然后提交会话。

#### 5.5.1.4 Delete

1. 删除记录和添加记录很相似，不过要把 add() 方法换成 delete() 方法，最后都需要调用 commit() 方法提交修改。下面的示例删除了 id(主键)为 2 的记录：

   ```python
   >>> note = Note.query.get(2)

   >>> db.session.delete(note)

   >>> db.session.commit()
   ```

### 5.5.2 在视图函数里操作数据库

1. 在视图函数里操作数据库的方式和我们在 Python Shell 中的练习大致相同，只不过需要一些额外的工作。比如把查询结果作为参数传入模板渲染出来，或是获取表单的字段值作为提交到数据库的数据。
2. 在这一节，我们将把上一节学习的所有数据库操作知识运用到一个简单的笔记程序中。这个程序可以让你创建、编辑和删除笔记，并在主页列出所有保存后的笔记。

#### 5.5.2.1 Create

1. 为了支持输入笔记内容，我们先创建一个用于填写新笔记的表单，如下所示：

   ```python
   from flask_wtf import FlaskForm
   from wtforms import TextAreaField, SubmitField
   from wtforms.validators import DataRequired

   class NewNoteForm(FlaskForm):
       body = TextAreaField('Body', validators=[DataRequired()])
       submit = SubmitField('Save')
   ```

2. 我们创建一个 new_note 视图，这个视图负责渲染创建笔记的模板，并处理表单的提交，如下所示。

   <center><b>demos/database/app.py：创建新笔记</b></center>

   ```python
   @app.route('/new', methods=['GET', 'POST'])
   def new_note():
       form = NewNoteForm()
       if form.validate_on_submit():
           body = form.body.data
           note = Note(body=body)
           db.session.add(note)
           db.session.commit()
           flash('Your note is saved.')
           return redirect(url_for('index'))
       return render_template('new_note.html', form=form)
   ```

3. 我们先来看看 form.validate_on_submit() 返回 True 时的处理代码。

4. 当表单被提交且通过验证时，我们获取表单 body 字段的数据，然后创建新的 Note 实例，将表单中 body 字段的值作为 body 参数传入，最后添加到数据库会话中并提交会话。这个过程接收用户通过表单提交的数据并保存到数据库中，最后我们使用 flash() 函数发送提示消息并重定向到 index 视图。

5. 表单在 new_note.html 模板中渲染，这里使用我们在第 4 章介绍的 form_field 宏渲染表单字段，传入 rows 和 cols 参数来定制 `<textarea>` 输入框 的大小：

   ```jinja2
   {% block content %}
       <h2>New Note</h2>
       <form method="post">
           {{ form.csrf_token }}
           {{ form_field(form.body, rows=5, cols=50) }}
           {{ form.submit }}
       </form>
   {% endblock %}
   ```

6. index 视图用来显示主页，目前它的所有作用就是渲染主页对应的模板：

   ```python
   @app.route('/')
   def index():
       return render_template('index.html')
   ```

7. 在对应的 index.html 模板中，我们添加一个指向创建新笔记页面的链接：

   ```html
   <h1>Notebook</h1>
   <a href="{{ url_for('new_note') }}">New Note</a>
   ```

#### 5.5.2.2 Read

1. 在上一节我们为程序实现了添加新笔记的功能，当你在创建笔记的页面单击保存后，程序会重定向到主页，提示的消息告诉你刚刚提交的笔记已经成功保存了，可是你却无法看到创建后的笔记。为了在主页列出所有保存的笔记，我们需要修改 index 视图，修改后的 index 视图如下所示。

   <center><b>demos/database/app.py：在视图函数中查询数据库记录并传入模板</b></center>

   ```python
   @app.route('/')
   def index():
       form = DeleteForm()
       notes = Note.query.all()
       return render_template('index.html', notes=notes, form=form)
   ```

2. 在新的 index 视图里，我们像在 Python Shell 中一样使用 Note.query.all() 查询所有 note 记录，然后把这个包含所有记录的列表作为 notes 变量传入模板。你已经猜到下一步了，没错，我们将在模板中将笔记们显示出来，如下所示。

   <center><b>demos/database/templates/index.html：在模板中渲染数据库记录</b></center>

   ```html
   <h1>Notebook</h1>
   <a href="{{ url_for('new_note') }}">New Note</a>
   <h4>{{ notes|length }} notes:</h4>
   {% for note in notes %}
       <div class="note">
           <p>{{ note.body }}</p>
       </div>
   {% endfor %}
   ```

3. 在模板中，我们迭代这个 notes 列表，调用 Note 对象的 body 属性(note.body)获取 body 字段的值。另外，我们还通过 length 过滤器获取笔记的数量。

#### 5.5.2.3 Update

1. 更新一条笔记和创建一条新笔记的实现代码几乎完全相同，首先是编辑笔记的表单：

   ```python
   class EditNoteForm(FlaskForm):
       body = TextAreaField('Body', validators=[DataRequired()])
       submit = SubmitField('Update')
   ```

2. 你会发现这和创建新笔记 NewNoteForm 唯一的不同就是提交字段的标签参数(作为 `<input>` 的 value 属性)，因此这个表单的定义也可以通过继承来简化：

   ```python
   class EditNoteForm(NewNoteForm):
       submit = SubmitField('Update')
   ```

3. 用来渲染更新笔记页面和处理更新表单提交的 edit_note 视图

   <center><b>database/app.py：更新笔记内容</b></center>

   ```python
   @app.route('/edit/<int:note_id>', methods=['GET', 'POST'])
   def edit_note(note_id):
       form = EditNoteForm()
       note = Note.query.get(note_id)
       if form.validate_on_submit():
           note.body = form.body.data
           db.session.commit()
           flash('Your note is updated.')
           return redirect(url_for('index'))
       form.body.data = note.body
       return render_template('edit_note.html', form=form)
   ```

4. 这个视图通过 URL 变量 note_id 获取要被修改的笔记的主键值(id 字段)，然后我们就可以使用 get() 方法获取对应的 Note 实例。当表单被提交且通过验证时，我们将表单中 body 字段的值赋给 note 对象的 body 属性，然后提交数据库会话，这样就完成了更新操作。和创建笔记相同，我们接着发送提示消息并重定向到 index 视图。

5. 唯一需要注意的是，在 GET 请求的执行流程中，我们添加了下面这行代码：

   ```python
   form.body.data = note.body
   ```

6. 因为要添加修改笔记内容的功能，那么当我们打开修改某个笔记的页面时，这个页面的表单中必然要包含笔记原有的内容。

7. 如果手动创建 HTML 表单，那么你可以通过将 note 记录传入模板，然后手动为对应字段中填入笔记的原有内容，比如：

   ```html
   <textarea name="body">{{ note.body }}</textarea>
   ```

8. 其他 input 元素则通过 value 属性来设置输入框中的值，比如：

   ```html
   <input name="foo" type="text" value="{{ note.title }}">
   ```

9. 使用 WTForms 可以省略这些步骤，当我们渲染表单字段时，如果表单字段的 data 属性不为空，WTForms 会自动把 data 属性的值添加到表单字段的 value 属性中，作为表单的值填充进去，我们不用手动为 value 属性赋值。因此，将存储笔记原有内容的 note.body 属性赋值给表单 body 字段的 data 属性即可在页面上的表单中填入原有的内容。

10. 模板的内容基本相同，这里不再赘述。最后的工作是在主页笔记列表中的每个笔记内容下添加一个编辑按钮，用来访问编辑页面：

    ```html
    {% for note in notes %}
        <div class="note">
            <p>{{ note.body }}</p>
            <a class="btn" href="{{ url_for('edit_note', note_id=note.id) }}">Edit</a>
        </div>
    {% endfor %}
    ```

11. 生成 edit_note 视图的 URL 时，我们传入当前 note 对象的 id(note.id) 作为 URL 变量 note_id 的值。

#### 5.5.2.4 Delete

1. 在程序中，删除的实现也非常简单，不过这里经常会有一个误区。大多数人通常会考虑在笔记内容下添加一个删除链接：

   ```html
   <a href="{{ url_for('delete_note', note_id=note.id) }}">Delete</a>
   ```

2. 这个链接指向用来删除笔记的 delete_note 视图：

   ```python
   @app.route('/delete/<int:note_id>')
   def delete_note(note_id):
       note = Note.query.get(note_id)
       db.session.delete(note)
       db.session.commit()
       flash('Your note is deleted.')
       return redirect(url_for('index'))
   ```

3. 虽然这一切看起来都很合理，但这种处理方式实际上会使程序处于 CSRF 攻击的风险之中。我们在第 2 章曾强调过，防范 CSRF 攻击的基本原则就是正确使用 GET 和 POST 方法。像删除这类修改数据的操作绝对不能通过 GET 请求实现，正确的做法是为删除操作创建一个表单，如下所示：

   ```python
   class DeleteNoteForm(FlaskForm):
       submit = SubmitField('Delete')
   ```

4. 这个表单类只有一个提交字段，因为我们只需要在页面上显示一个删除按钮来提交表单。删除表单的提交请求由 delete_note 视图处理，如下代码所示。

   ```python
   @app.route('/delete/<int:note_id>', methods=['POST'])
   def delete_note(note_id):
       form = DeleteForm()
       if form.validate_on_submit():
           note = Note.query.get(note_id) # 获取对应记录
           db.session.delete(note) # 删除记录
           db.session.commit() # 提交修改
           flash('Your note is deleted.')
   　　else:
           abort(400)
           return redirect(url_for('index'))
   ```

5. 在 delete_note 视图的 app.route() 中，methods 列表仅填入了 POST， 这会确保该视图仅监听 POST 请求。

6. 和编辑笔记的视图类似，这个视图接收 note_id(主键值) 作为参数。如果提交表单且通过验证(唯一需要被验证的是 CSRF 令牌)，就使用 get() 方法查询对应的记录，然后调用 db.session.delete() 方法删除并提交数据库会话。如果验证出错则使用 abort() 函数返回 400 错误响应。

7. 因为删除按钮要在主页的笔记内容下添加，我们需要在 index 视图中实例化 DeleteNote-Form 类，然后传入模板。在 index.html 模板中，我们渲染这个表单：

   ```jinja2
   {% for note in notes %} <p>{{ note.body }}</p>
       <div class="note">
           <a class='btn' href="{{ url_for('edit_note', note_id=note.id) }}">Edit</a>
           <form method="post" action="{{ url_for('delete_note', note_id=note.id) }}"> {{ form.csrf_token }} </form>
       </div>
   {% endfor %}
   ```

8. 我们将表单的 action 属性设置为删除当前笔记的 URL 。构建 URL 时，URL 变量 note_id 的值通过 note.id 属性获取，当单击提交按钮时，会将请求发送到 action 属性中的 URL 。添加删除表单的主要目的就是防止 CSRF 攻击，所以不要忘记渲染 CSRF 令牌字段 form.csrf_token 。

9. 在 HTML 中，`<a>` 标签会显示为链接，而提交按钮会显示为按钮，为了让编辑和删除笔记的按钮显示相同的样式，我们为这两个元素使用了同一个 CSS 类 ".btn"，具体可以在 static/style.css 文件中查看。作为替代，你可以考虑使用 JavaScript 创建监听函数，当删除按钮按下时，提交对应的隐藏表单。

10. 如果你运行了示例程序，请访问 <http://localhost:5000> 打开示例程序的主页，你可以体验我们在这一节实现的所有功能。

## 5.6 定义关系

1. 在关系型数据库中，我们可以通过关系让不同表之间的字段建立联系。一般来说，定义关系需要两步，分别是创建外键和定义关系属性。在更复杂的多对多关系中，我们还需要定义关联表来管理关系。这一节，我们会学习如何使用 SQLAlchemy 在模型之间建立几种基础的关系模式。

### 5.6.1 配置 Python Shell 上下文

1. 在上面的许多操作中，每一次使用 flask shell 命令启动 Python Shell 后都要从 app 模块里导入 db 对象和相应的模型类。

2. 为什么不把它们自动集成到 Python Shell 上下文里呢？就像 Flask 内置的 app 对象一样。这当然可以实现！我们可以使用 app.shell_context_processor 装饰器注册一个 shell 上下文处理函数。它和模板上下文处理函数一样，也需要返回包含变量和变量值的字典，如下代码所示。

   <center><b>app.py：注册 shell 上下文处理函数</b></center>

   ```python
   # ...
   @app.shell_context_processor def make_shell_context():
       return dict(db=db, Note=Note) # 等同于{'db': db, 'Note': Note}
   ```

3. 当你使用 flask shell 命令启动 Python Shell 时，所有使用 app.shell_context_processor 装饰器注册的 shell 上下文处理函数都会被自动执行，这会将 db 和 Note 对象推送到 Python Shell 上下文里：

   ```python
   $ flask shell

   >>> db

   <SQLAlchemy engine=sqlite:///Path/to/your/data.db>

   >>> Note

   <class 'app.Note'>
   ```

4. 在这一节演示各种数据库关系时，我们将编写更多的模型类。在示例程序中，它们都使用 shell 上下文处理函数添加到 shell 上下文中，因此你可以直接在 Python Shell 使用，不用手动导入。

### 5.6.2 一对多

1. 我们将以作者和文章来演示一对多关系：一个作者可以写作多篇文章。一对多关系示意图如下所示

   <center><b>一对多示意图</b></center>

   <img src="https://studentcwz-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/%E4%B8%80%E5%AF%B9%E5%A4%9A%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="一对多示意图" style="zoom:50%;" />

2. 在示例程序中，Author 类用来表示作者，Article 类用来表示文章，如下所示。

   ```python
   # ...
   class Author(db.Model):
       id = db.Column(db.Integer, primary_key=True)
       name = db.Column(db.String(70), unique=True)
       phone = db.Column(db.String(20))

   class Article(db.Model):
       id = db.Column(db.Integer, primary_key=True)
       title = db.Column(db.String(50), index=True)
       body = db.Column(db.Text)
   ```

3. 我们将在这两个模型之间建立一个简单的一对多关系，建立这个一对多关系的目的是在表示作者的 Author 类中添加一个关系属性 articles，作为集合(collection)属性，当我们对特定的 Author 对象调用 articles 属性会返回所有相关的 Article 对象。我们会在下面介绍如何一步步定义这个一对多关系。

#### 5.6.2.1 定义外键

1. 定义关系的第一步是创建外键。外键是(foreign key)用来在 A 表存储 B 表的主键值以便和 B 表建立联系的关系字段。因为外键只能存储单一数据(标量)，所以外键总是在多这一侧定义，多篇文章属于同一个作者，所以我们需要为每篇文章添加外键存储作者的主键值以指向对应的作者。在 Article 模型中，我们定义一个 author_id 字段作为外键：

   ```python
   class Article(db.Model):
       ...
       author_id = db.Column(db.Integer, db.ForeignKey('author.id'))
   ```

2. 这个字段使用 db.ForeignKey 类定义为外键，传入关系另一侧的表名和主键字段名，即 author.id 。实际的效果是将 article 表的 author_id 的值限制为 author 表的 id 列的值。它将用来存储 author 表中记录的主键值，如下图所示

   <center><b>外键示意图</b></center>

   <img src="https://studentcwz-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/%E5%A4%96%E9%94%AE%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="外键示意图" style="zoom:50%;" />

3. 外键字段的命名没有限制，因为要连接的目标字段是 author 表的 id 列，所以为了便于区分而将这个外键字段的名称命名为 author_id。

4. 传入 ForeignKey 类的参数 author.id，其中 author 指的是 Author 模型对应的表名称，而 id 指的是字段名，即表名.字段名。

5. 模型类对应的表名由 Flask-SQLAlchemy 生成，默认为类名称的小写形式，多个单词通过下划线分隔，你也可以显式地通过 `__tablename__` 属性自己指定，后面不再提示。

### 5.6.2.2 定义关系属性

1. 定义关系的第二步是使用关系函数定义关系属性。关系属性在关系的出发侧定义，即一对多关系的一这一侧。一个作者拥有多篇文章，在 Author 模型中，我们定义了一个 articles 属性来表示对应的多篇文章：

   ```python
   class Author(db.Model):
       ...
       articles = db.relationship('Article')
   ```

2. 关系属性的名称没有限制，你可以自由修改。它相当于一个快捷查询，不会作为字段写入数据库中。

3. 这个属性并没有使用 Column 类声明为列，而是使用了 db.relationship() 关系函数定义为关系属性，因为这个关系属性返回多个记录，我们称之为集合关系属性。

4. relationship() 函数的第一个参数 为关系另一侧的模型名称，它会告诉 SQLAlchemy 将 Author 类与 Article 类建立关系。

5. 当这个关系属性被调用时，SQLAlchemy 会找到关系另一侧(即 article 表)的外键字段(即 author_id)，然后反向查询 article 表中所有 author_id 值为当前表主键值(即 author.id)的记录，返回包含这些记录的列表，也就是返回某个作者对应的多篇文章记录。

6. 下面我们会在 Python Shell 中演示如何对实际的对象建立关系。我们先创建一个作者记录和两个文章记录，并添加到数据库会话中：

   ```python
   >>> foo = Author(name='Foo')

   >>> spam = Article(title='Spam')

   >>> ham = Article(title='Ham')

   >>> db.session.add(foo)

   >>> db.session.add(spam) >>> db.session.add(ham)
   ```

#### 5.6.2.3 建立关系

1. 建立关系有两种方式，第一种方式是为外键字段赋值，比如：

   ```python
   >>> spam.author_id = 1

   >>> db.session.commit()
   ```

2. 我们将 spam 对象的 author_id 字段的值设为 1 ，这会和 id 值为 1 的 Author 对象建立关系。提交数据库改动后，如果我们对 id 为 1 的 foo 对象 调用 articles 关系属性，会看到 spam 对象包括在返回的 Article 对象列表中：

   ```python
   >>> foo.articles [<Article u'Spam'>, <Article u'Ham'>]
   ```

3. 另一种方式是通过操作关系属性，将关系属性赋给实际的对象即可建立关系。集合关系属性可以像列表一样操作，调用 append() 方法来 与一个 Article 对象建立关系：

   ```python
   >>> foo.articles.append(spam)

   >>> foo.articles.append(ham)

   >>> db.session.commit()
   ```

4. 我们也可以直接将关系属性赋值给一个包含 Article 对象的列表。

5. 和前面的第一种方式类似，为了让改动生效，我们需要调用 db.session.commit() 方法提交数据库会话。建立关系后，存储外键的 author_id 字段会自动获得正确的值，而调用 Author 实例的关系属性 articles 时，会获得所有建立关系的 Article 对象：

   ```python
   >>> spam.author_id
   1
   >>> foo.articles
   [<Article u'Spam'>, <Article u'Ham'>]
   ```

6. 和主键类似，外键字段由 SQLAlchemy 管理，我们不需要手动设置。当通过关系属性建立关系后，外键字段会自动获得正确的值。

7. 在后面的示例程序中，我们会统一使用第二种方式，即通过关系属性来建立关系。

8. 和 append() 相对，对关系属性调用 remove() 方法可以与对应的 Article 对象解除关系：

   ```python
   >>> foo.articles.remove(spam)

   >>> db.session.commit()

   >>> foo.articles [<Article u'Ham'>]
   ```

9. 你也可以使用 pop() 方法操作关系属性，它会与关系属性对应的列表的最后一个 Article 对象解除关系并返回该对象。

10. 不要忘记在操作结束后需要调用 commit() 方法提交数据库会话，这样才可以把改动写入数据库。

11. 在上面我们提到过，使用关系函数定义的属性不是数据库字段，而是类似于特定的查询函数。当某个 Article 对象被删除时，在对应 Author 对象的 articles 属性调用时返回的列表也不会包含该对象。

12. 在关系函数中，有很多参数可以用来设置调用关系属性进行查询时的具体行为。常用的关系函数参数如下表所示。

    <center><b>常用的 SQLAlchemy 关系函数参数</b></center>

    |     参数名     |                             说明                             |
    | :------------: | :----------------------------------------------------------: |
    | back_populates | 定义反向引用，用于建立双向关系，在关系的另一侧也必须显式定义关系属性 |
    |    backref     | 添加反向引用，自动在另一侧建立关系属性，是 back_populates 的简化版 |
    |      lazy      |                     指定如何加载相关记录                     |
    |    uselist     | 指定是否使用列表的形式加载记录，设为 False 则使用标量(scalar) |
    |    cascabe     |                         设置级联操作                         |
    |    order_by    |                 指定加载相关记录时的排序方式                 |
    |   secondary    |                   在多对多关系中指定关联表                   |
    |  primaryjoin   |                指定多对多关系中的一级联结条件                |
    | secondaryjoin  |                指定多对多关系中的二级联结条件                |

13. 当关系属性被调用时，关系函数会加载相应的记录，下表列出了控制关系记录加载方式的 lazy 参数的常用选项。

    <center><b>常用的 SQLAlchemy 关系记录加载方式(lazy 参数可选值)</b></center>

    | 关系加载方式 |                             说明                             |
    | :----------: | :----------------------------------------------------------: |
    |    select    | 在必要时一次性加载记录，返回包含记录的列表(默认值)，等同于 lazy=True |
    |    joined    |     和父查询一样加载记录，但使用联结，等同于 lazy=False      |
    |  immediate   |                     一旦父查询加载就加载                     |
    |   subquery   |               类似于 joined，不过将使用子查询                |
    |   dynamic    | 不直接加载记录，而是返回一个包含相关记录的 query 对象，以便再继续附加查询函数对结果进行过滤 |

14. dynamic 选项仅用于集合关系属性，不可用于多对一、一对一或是在关系函数中将 uselist 参数设为 False 的情况。

15. 许多教程和示例使用 dynamic 来动态加载所有集合关系属性对应的记录，这是应该避免的行为。使用 dynamic 加载方式意味着每次操作关系都会执行一次 SQL 查询，这会造成潜在的性能问题。大多数情况下我们只需要使用默认值(select)，只有在调用关系属性会返回大量记录，并且总是需要对关系属性返回的结果附加额外的查询时才需要使用动态加载(lazy='dynamic')。

#### 5.6.2.4 建立双向关系

1. 我们在 Author 类中定义了集合关系属性 articles ，用来获取某个作者拥有的多篇文章记录。在某些情况下，你也许希望能在 Article 类中定义一个类似的 author 关系属性，当被调用时返回对应的作者记录，这类返回单个值的关系属性被称为标量关系属性。而这种两侧都添加关系属性 获取对方记录的关系我们称之为双向关系(bidirectional relationship)。

2. 双向关系并不是必须的，但在某些情况下会非常方便。双向关系的建立很简单，通过在关系的另一侧也创建一个 relationship() 函数，我们就可以在两个表之间建立双向关系。我们使用作家(Writer)和书(Book)的一对多关系来进行演示，建立双向关系后的 Writer 和 Book 类如下代码所示。

   <center><b>database/app.py：基于一对多关系的双向关系</b></center>

   ```python
   class Writer(db.Model):
       id = db.Column(db.Integer, primary_key=True)
       name = db.Column(db.String(70), unique=True)
       books = db.relationship("Book", back_populates="writer")

   class Book(db.Model):
      id = db.Column(db.Integer, primary_key=True)
      title = db.Column(db.String(50), index=True)
      writer_id = db.Column(db.Integer, db.ForeignKey("writer.id"))
      writer = db.relationship("Writer", back_populates="books")
   ```

3. 在多这一侧的 Book(书)类中，我们新创建了一个 writer 关系属性，这是一个标量关系属性，调用它会获取对应的 Writer(作者)记录；而在 Writer(作者)类中的 books 属性则用来获取对应的多个 Book(书)记录。在关系函数中，我们使用 back_populates 参数来连接对方，back_populates 参数的值需要设为关系另一侧的关系属性名。为了方便演示，我们先创建 1 个 Writer 和 2 个 Book 记录，并添加到数据库中：

   ```python
   >>> king = Writer(name='Stephen King')
   >>> carrie = Book(name='Carrie')
   >>> it = Book(name='IT')
   >>> db.session.add(king)
   >>> db.session.add(carrie)
   >>> db.session.add(it)
   >>> db.session.commit()
   ```

4. 设置双向关系后，除了通过集合属性 books 来操作关系，我们也可以使用标量属性 writer 来进行关系操作。比如，将一个 Writer 对象赋值给某个 Book 对象的 writer 属性，就会和这个 Book 对象建立关系：

   ```python
   >>> carrie.writer = king
   >>> carrie.writer
   <Writer u'Stephen King'>
   >>> king.books
   [<Book u'Carrie'>]
   >>> it.writer = writer
   >>> king.books
   [<Book u'Carrie'>, <Book u'IT'>]
   ```

5. 相对的，将某个 Book 的 writer 属性设为 None，就会解除与对应 Writer 对象的关系：

   ```python
   >>> carrie.writer = None
   >>> king.books [<Book u'IT'>]
   >>> db.session.commit()
   ```

6. 需要注意的是，我们只需要在关系的一侧操作关系。当为 Book 对象的 writer 属性赋值后，对应 Writer 对象的 books 属性的返回值也会自动包含这个 Book 对象。反之，当某个 Writer 对象被删除时，对应的 Book 对象的 writer 属性被调用时的返回值也会被置为空(即 NULL，会返回 None)。

7. 其他关系模式建立双向关系的方式完全相同，在下面介绍不同的关系模式时我们会简单说明。

#### 5.6.2.5 使用 backref 简化关系定义

1. 在介绍关系函数的参数时，我们曾提到过，使用关系函数中的 backref 参数可以简化双向关系的定义。以一对多关系为例，backref 参数用来自动为关系另一侧添加关系属性，作为反向引用(back reference)，赋予的值会作为关系另一侧的关系属性名称。

2. 比如，我们在 Author 一侧的关系函数中将 backref 参数设为 author，SQLAlchemy 会自动为 Article 类添加一个 author 属性。为了避免和前面的示例命名冲突，我们使用歌手(Singer)和歌曲(Song)的一对多关系作为演示，分别创建 Singer 和 Song 类，如下代码所示。

   <center><b>database/app.py：使用 backref 建立双向关系</b></center>

   ```python
   class Singer(db.Model):
       id = db.Column(db.Integer, primary_key=True)
       name = db.Column(db.String(70), unique=True)
       songs = db.relationship("Song", backref="singer")

   class Song(db.Model):
      id = db.Column(db.Integer, primary_key=True)
      name = db.Column(db.String(50), index=True)
      singer_id = db.Column(db.Integer, db.ForeignKey("singer.id"))
   ```

3. 在定义集合属性 songs 的关系函数中，我们将 backref 参数设为 singer ，这会同时在 Song 类中添加了一个 singer 标量属性。这时我们仅需要定义一个关系函数，虽然 singer 是一个看不见的关系属性，但在使用上和定义两个关系函数并使用 back_populates 参数的效果完全相同。

4. 需要注意的是，使用 backref 允许我们仅在关系一侧定义另一侧的关系属性，但是在某些情况下，我们希望可以对在关系另一侧的关系属性进行设置，这时就需要使 backref() 函数。

5. backref() 函数接收第一个参数作为在关系另一侧添加的关系属性名，其他关键字参数会作为关系另一侧关系函数的参数传入。比如，我们要在关系另一侧看不见的 relationship() 函数中将 uselist 参数设为 False ，可以这样实现：

   ```python
   class Singer(db.Model):
       ...
       songs = relationship("Song", backref=backref("singer", uselist=False))
   ```

6. 尽管使用 backref 非常方便，但通常来说显式好过隐式，所以我们应该尽量使用 back_populates 定义双向关系。为了便于理解，在本书的示例程序中都将使用 back_populates 来建立双向关系。

### 5.6.3　多对一

1. 一对多关系反过来就是多对一关系，这两种关系模式分别从不同的视角出发。一个作者拥有多篇文章，反过来就是多篇文章属于同一个作者。

2. 为了便于区分，我们使用居民和城市来演示多对一关系：多个居民居住在同一个城市。多对一关系如下所示。

   <center><b>多对一示意图</b></center>

   <img src="https://studentcwz-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/%E5%A4%9A%E5%AF%B9%E4%B8%80%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="多对一示意图" style="zoom:50%;" />

3. 在示例程序中，Citizen 类表示居民，City 类表示城市。建立多对一关系后，我们将在 Citizen 类中创建一个标量关系属性 city，调用它可以获取单个 City 对象。

4. 我们在前面介绍过，关系属性在关系模式的出发侧定义。当出发点 在多这一侧时，我们希望在 Citizen 类中添加一个关系属性 city 来获取对应的城市对象，因为这个关系属性返回单个值，我们称之为标量关系属性。在定义关系时，外键总是在多这一侧定义，所以在多对一关系中外键和关系属性都定义在多这一侧，即 City 类中，如下代码所示。

   <center><b>database/app.py：建立多对一关系</b></center>

   ```python
   class Citizen(db.Model):
       id = db.Column(db.Integer, primary_key=True)
       name = db.Column(db.String(70), unique=True)
       city_id = db.Column(db.Integer, db.ForeignKey("city.id"))
       city = db.relationship("City")

   class City(db.Model):
      id = db.Column(db.Integer, primary_key=True)
      name = db.Column(db.String(30), unique=True)
   ```

5. 这时定义的 city 关系属性是一个标量属性(返回单一数据)。当 Citizen.city 被调用时，SQLAlchemy 会根据外键字段 city_id 存储的值查找对应的 City 对象并返回，即居民记录对应的城市记录。

6. 当建立双向关系时，如果不使用 backref ，那么一对多和多对一关系模式在定义上完全相同，这时可以将一对多和多对一视为同一种关系模式。在后面我们通常都会为一对多或多对一建立双向关系，这时将弱化这两种关系的区别，一律称为一对多关系。

### 5.6.4　一对一

1. 我们将使用国家和首都来演示一对一关系：每个国家只有一个首都；反过来说，一个城市也只能作为一个国家的首都。一对一关系示意如下所示。

   <center><b>一对一关系示意图</b></center>

   <img src="https://studentcwz-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="一对一关系示意图" style="zoom:50%;" />

2. 在示例程序中，Country 类表示国家，Capital 类表示首都。建立一对一关系后，我们将在 Country 类中创建一个标量关系属性 capital，调用它会获取单个 Capital 对象；我们还将在 Capital 类中创建一个标量关系属性 country，调用它会获取单个的 Country 对象。

3. 一对一关系实际上是通过建立双向关系的一对多关系的基础上转化而来。我们要确保关系两侧的关系属性都是标量属性，都只返回单个值，所以要在定义集合属性的关系函数中将 uselist 参数设为 False ，这时一对多关系将被转换为一对一关系。如下代码基于建立双向关系的一对多关系实现了一对一关系。

   <center><b>database/app.py：建立一对一关系</b></center>

   ```python
   class Country(db.Model):
       id = db.Column(db.Integer, primary_key=True)
       name = db.Column(db.String(30), unique=True)
       capital = db.relationship("Capital", uselist=False)

   class Capital(db.Model):
      id = db.Column(db.Integer, primary_key=True)
      name = db.Column(db.String(30), unique=True)
      country_id = db.Column(db.Integer, db.ForeignKey("country.id"))
      country = db.relationship("Country")
   ```

4. 多这一侧本身就是标量关系属性，不用做任何改动。而一这一侧的集合关系属性，通过将 uselist 设为 False 后，将仅返回对应的单个记录，而且无法再使用列表语义操作：

   ```python
   >>> china = Country(name='China')
   >>> beijing = Capital(name='Beijing')
   >>> db.session.add(china)
   >>> db.session.add(beijing)
   >>> db.session.commit()
   >>> china.capital = beijing
   >>> china.capital
   <Capital 1>
   >>> beijing.country
   u'China'
   >>> tokyo = Capital(name'Tokyo')
   >>> china.capital.append(tokyo)
   Traceback (most recent call last):
   File "<console>", line 1, in <module>
   AttributeError: 'Capital' object has no attribute 'append'
   ```

### 5.6.5　多对多

1. 我们将使用学生和老师来演示多对多关系：每个学生有多个老师，而每个老师有多个学生。多对多关系模式示意图如下所示。

   <center><b>多对多关系示意图</b></center>

   <img src="https://studentcwz-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/%E5%A4%9A%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%85%B3%E7%B3%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="多对多的关系示意图" style="zoom:50%;" />

2. 在示例程序中，Student 类表示学生，Teacher 类表示老师。在这两个模型之间建立多对多关系后，我们需要在 Student 类中添加一个集合关系属性 teachers ，调用它可以获取某个学生的多个老师，而不同的学生可以和同一个老师建立关系。

3. 在一对多关系中，我们可以在多这一侧添加外键指向一这一侧，外键只能存储一个记录，但是在多对多关系中，每一个记录都可以与关系另一侧的多个记录建立关系，关系两侧的模型都需要存储一组外键。

4. 在 SQLAlchemy 中，要想表示多对多关系，除了关系两侧的模型外，我们还需要创建一个关联表(association table)。关联表不存储数据，只用来存储关系两侧模型的外键对应关系，如下代码所示。

   <center><b>database/app.py：建立多对多关系</b></center>

   ```python
   association_table = db.Table(
       "association", db.Column("student_id", db.Integer, db.Foreign)
   )

   class Student(db.Model):
      id = db.Column(db.Integer, primary_key=True)
      name = db.Column(db.String(70), unique=True)
      grade = db.Column(db.String(20))
      teachers = db.relationship(
          "Teacher", secondary=association_table, back_populates="students"
      )


   class Teacher(db.Model):
      id = db.Column(db.Integer, primary_key=True)
      name = db.Column(db.String(70), unique=True)
      office = db.Column(db.String(20))
   ```

5. 关联表使用 db.Table 类定义，传入的第一个参数是关联表的名称。我们在关联表中定义了两个外键字段：teacher_id 字段存储 Teacher 类的主键，student_id 存储 Student 类的主键。借助关联表这个中间人存储的外键对，我们可以把多对多关系分化成两个一对多关系，如下所示。

   <center><b>关联表示意图</b></center>

   <img src="https://studentcwz-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/%E5%85%B3%E8%81%94%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="关联表示意图" style="zoom: 67%;" />

6. 当我们需要查询某个学生记录的多个老师时，我们先通过学生和关联表的一对多关系查找所有包含该学生的关联表记录，然后就可以从这些记录中再进一步获取每个关联表记录包含的老师记录。

7. 以上图中的随机数据为例，假设学生记录的 id 为 1 ，那么通过查找关联表中 student_id 字段为 1 的记录，就可以获取到对应的 teacher_id 值(分别为 3 和 4)，通过外键值就可以在teacher表里获取 id 为 3 和 4 的记录，最终，我们就获取到 id 为 1 的学生记录相关联的所有老师记录。

8. 我们在 Student 类中定义一个 teachers 关系属性用来获取老师集合。 在多对多关系中定义关系函数，除了第一个参数是关系另一侧的模型名称外，我们还需要添加一个 secondary 参数，把这个值设为关联表的名称。

9. 为了便于实现真正的多对多关系，我们需要建立双向关系。建立双向关系后，多对多关系会变得更加直观。在 Student 类上的 teachers 集合属性会返回所有关联的老师记录，而在 Teacher 类上的 students 集合属性会返回所有相关的学生记录：

   ```python
   class Student(db.Model):
       ...
       teachers = db.relationship(
           "Teacher", secondary=association_table, back_populates="students"
       )

   class Teacher(db.Model):
      ...
      students = db.relationship(
          "Student", secondary=association_table, back_populates="teachers"
      )
   ```

10. 除了在声明关系时有所不同，多对多关系模式在操作关系时和其他关系模式基本相同。

11. 调用关系属性 student.teachers 时，SQLAlchemy 会直接返回关系另一侧的 Teacher 对象，而不是关联表记录，反之亦同。和其他关系模式中的集合关系属性一样，我们可以将关系属性 teachers 和 students 像列表一样操作。比如，当你需要为某一个学生添加老师时，对关系属性使用 append() 方法即可。如果你想要解除关系，那么可以使用 remove() 方法。

12. 关联表由 SQLAlchemy 接管，它会帮我们管理这个表：我们只需要像往常一样通过操作关系属性来建立或解除关系，SQLAlchemy 会自动在关联表中创建或删除对应的关联表记录，而不用手动操作关联表。

13. 同样的，在多对多关系中我们也只需要在关系的一侧操作关系。当为学生 A 的 teachers 添加了老师B后，调用老师 B 的 students 属性时返回的学生记录也会包含学生A，反之亦同。

14. 本节的内容也许对你来说有些过于复杂和陌生，你可以先放一放， 等到后面学习了实际操作后再回来重读，你就会明白大部分内容了。

## 5.7　更新数据库表

1. 模型类(表)不是一成不变的，当你添加了新的模型类，或是在模型类中添加了新的字段，甚至是修改了字段的名称或类型，都需要更新表。在前面我们把数据库表类比成盛放货物的货架，这些货架是固定生成的。当我们在操控程序(DBMS/ORM)上变更了货架的结构时，仓库的货架也要根据变化相应进行调整。而且，当货架的结构产生变动时，我们还需要考虑如何处理货架上的货物(数据)。

2. 当你在数据库的模型中添加了一个新的字段后，比如在 Note 模型里添加了一个存储笔记创建时间的 timestamp 字段。这时你可能想要立刻启动程序看看效果，遗憾的是，你看到了下面的报错信息：

   ```text
   OperationalError: (sqlite3.OperationalError) no such column: note.timestamp [...]
   ```

3. 这段错误消息指出 note 表中没有 timestamp 列，并在中括号里给出了查询所对应的 SQL 原语。之所以会出现这个错误，是因为数据库表并不会随着模型的修改而自动更新。想想我们之前关于仓库的比喻，仓库里来了一批新类型的货物，可我们还没为它们安排相应的货架，这当然要出错了。下面我们会学习如何更新数据库。

### 5.7.1　重新生成表

1. 重新调用 create_all() 方法并不会起到更新表或重新创建表的作用。如果你并不在意表中的数据，最简单的方法是使用 drop_all() 方法删除表以及其中的数据，然后再使用 create_all() 方法重新创建：

   ```python
   >>> db.drop_all()
   >>> db.create_all()
   ```

2. 这会清除数据库里的原有数据，请勿在生产环境下使用。为了方便开发，我们修改 initdb 命令函数的内容，为其增加一个 `--drop` 选项来支持删除表和数据库后进行重建，如下所示。

   <center><b>database/app.py：支持删除表后重建</b></center>

   ```python
   @app.cli.command()
   @click.option("--drop", is_flag=True, help="Create after drop.")
   def initdb(drop):
       """Initialize the database."""
       if drop:
           click.confirm(
               "This operation will delete the database, do you want to continue?"
           )
           db.drop_all()
           click.echo("Drop tables.")
       db.create_all()
       click.echo("Initialized database.")
   ```

3. 在这个命令函数前，我们使用 click 提供的 option 装饰器为命令添加了一个 `--drop` 选项，将 is_flag 参数设为 True 可以将这个选项声明为布尔值标志(boolean flag)。

4. `--drop` 选项的值作为 drop 参数传入命令函数，如果提供了这个选项，那么 drop 的值将是 True ，否则为 False 。

5. 因为添加 `--drop` 选项会直接清空数据库内容，如果需要，也可以通过 click.confirm() 函数添加一个确认提示，这样只有输入 y 或 yes 才会继续执行操作。

6. 现在，执行下面的命令会重建数据库和表：

   ```bash
   flask initdb --drop
   ```

7. 当使用 SQLite 时，直接删除 data.db 文件和调用 drop_all() 方法效果 相同，而且更直接，不容易出错。

### 5.7.2　使用Flask-Migrate迁移数据库

1. 在开发时，以删除表再重建的方式更新数据库简单直接，但明显的缺陷是会丢掉数据库中的所有数据。在生产环境下，你绝对不会想让数据库里的数据都被删除掉，这时你需要使用数据库迁移工具来完成这个工作。

2. SQLAlchemy 的开发者 Michael Bayer 写了一个数据库迁移工具 `——Alembic` 来帮助我们实现数据库的迁移，数据库迁移工具可以在不破坏数据的情况下更新数据库表的结构。

3. 蒸馏器(Alembic)是炼金术士最重要的工具，要学习 SQL 炼金术(SQLAlchemy)，我们当然要掌握蒸馏器的使用。

4. 扩展 Flask-Migrate 集成了 Alembic ，提供了一些 flask 命令来简化迁移工作，我们将使用它来迁移数据库。Flask-Migrate 及其依赖(主要是 Alembic)可以使用 Pipenv 安装：

   ```bash
   pipenv install flask-migrate
   ```

5. 在程序中，我们实例化 Flask-Migrate 提供的 Migrate 类，进行初始化操作：

   ```python
   from flask import Flask
   from flask_sqlalchemy import SQLAlchemy
   from flask_migrate import Migrate

   app = Flask(__name__)
   ...

   db = SQLAlchemy(app)
   migrate = Migrate(app, db)  # 在 db 对象创建后调用
   ```

6. 实例化 Migrate 类时，除了传入程序实例 app ，还需要传入实例化 Flask-SQLAlchemy 提供的 SQLAlchemy 类创建的 db 对象作为第二个参数。

#### 5.7.2.1 创建迁移环境

1. 在开始迁移数据之前，需要先使用下面的命令创建一个迁移环境：

   ```bash
   flask db init
   ```

2. Flask-Migrate 提供了一个命令集，使用 db 作为命名集名称，它提供的命令都以 flask db 开头。你可以在命令行中输入 flask--help 查看所有可用的命令和说明。

3. 迁移环境只需要创建一次。这会在你的项目根目录下创建一个 migrations 文件夹，其中包含了自动生成的配置文件和迁移版本文件夹。

#### 5.7.2.2 生成迁移脚本

1. 使用 migrate 子命令可以自动生成迁移脚本：

   ```bash
   $ flask db migrate -m "add note timestamp"
   ...
   INFO [alembic.autogenerate.compare] Detected added column 'message.timestamp Generating /Path/to/your/database/migrations/versions/c52a02014635_add note_timestamp.py
   ```

2. 这条命令可以简单理解为在 flask 里对数据库(db)进行迁移(migrate)。-m 选项用来添加迁移备注信息。从上面的输出信息我们可以看到，Alembic 检测出了模型的变化：表 note 新添加了一个 timestamp 列，并且相应生成了一个迁移脚本 c52a02014635_add_note_timestamp.py，脚本的内容如下所示：

   <center><b>migrations/versions/c52a02014635_add_note_timestamp.py：迁移脚本示例</b></center>

   ```python
   """add note timestamp Revision ID: c52a02014635 """
   from alembic import op
   import sqlalchemy as sa

   # ...
   def upgrade():
      # ### commands auto generated by Alembic - please adjust! ###
       op.add_column(
           "note", sa.Column("timestamp", sa.DateTime(), nullable=True)
       )  # ### end Alembic commands ###


   def downgrade():
      # ### commands auto generated by Alembic - please adjust! ###
       op.drop_column("note", "timestamp")  # ### end Alembic commands ###
   ```

3. 从上面的代码可以看出，迁移脚本主要包含了两个函数：upgrade() 函数用来将改动应用到数据库，函数中包含了向表中添加 timestamp 字段的命令；而 downgrade() 函数用来撤销改动，包含了删除 timestamp 字段的命令。

4. 就像这两个函数中的注释所说的，迁移命令是由 Alembic 自动生成的，其中可能包含错误，所以有必要在生成后检查一下。

5. 因为每一次迁移都会生成新的迁移脚本，而且 Alembic 为每一次迁移都生成了修订版本(revision)ID，所以数据库可以恢复到修改历史中的任一点。正因为如此，迁移环境中的文件也要纳入版本控制。

6. 有些复杂的操作无法实现自动迁移，这时可以使用 revision 命令手 动创建迁移脚本。这同样会生成一个迁移脚本，不过脚本中的 upgrade() 和 downgrade() 函数都是空的。你需要使用 Alembic 提供的 Operations 对象指令在这两个函数中实现具体操作，具体可以访问 Alembic 官方文档查看。

#### 5.7.2.3 更新数据库

1. 生成了迁移脚本后，使用 upgrade 子命令即可更新数据库：

   ```bash
   >>> $ flask db upgrade
   ...
   INFO [alembic.runtime.migration] Running upgrade -> c52a02014635, add note timestamp
   ```

2. 如果还没有创建数据库和表，这个命令会自动创建；如果已经创建，则会在不损坏数据的前提下执行更新。

3. 如果你想回滚迁移，那么可以使用 downgrade 命令(降级)，它会撤销最后一次迁移在数据库中的改动，这在开发时非常有用。

4. 比如，当你执行 upgrade 命令后发现某些地方出错了，这时就可以执行 flask db downgrade 命令进行回滚，删除对应的迁移脚本，重新生成迁移脚本后再进行更新(upgrade)。

5. 虽然我们更新了数据库，但是之前创建的记录中并没有 timestamp 字段，所以这些记录的 timestamp 字段的值将为空。如果你需要为旧的数据添加默认的 timestamp 字段值，可以手动操作。

### 5.7.3　开发时是否需要迁移？

1. 在生产环境下，当对数据库结构进行修改后，进行数据库迁移是必要的。因为你不想损坏任何数据，毕竟数据是无价的。在生成自动迁移脚本后，执行更新之前，对迁移脚本进行检查，甚至是使用备份的数据 库进行迁移测试，都是有必要的。
2. 而在开发环境中，你可以按需要选择是否进行数据迁移。对于大多数程序来说，我们可以在开发时使用虚拟数据生成工具来生成虚拟数 据，从而避免手动创建记录进行测试。这样每次更改表结构时，可以直 接清除后重新生成，然后生成测试数据，这要比执行一次迁移简单很多(在后面我们甚至会学习通过一条命令完成所有工作)，除非生成虚拟数据耗费的时间过长。
3. 另外，在本地开发时通常使用 SQLite 作为数据库引擎。SQLite 不支持 ALTER 语句，而这正是迁移工具依赖的工作机制。也就是说，当 SQLite 数据库表的字段删除或修改后，我们没法直接使用迁移工具进行更新，你需要手动添加迁移代码来进行迁移。在开发中，修改和删除列是很常见的行为，手动操作迁移会花费太多的时间。
4. 对于 SQLite，迁移工具一般使用 move and copy 的工作流(创建新表、转移数据、删除旧表)达到类似的效果，具体可访问 <http://alembic.zzzcomputing.com/en/latest/batch.html> 了解。
5. 当然，这些仅仅是从方便的角度考虑，如果你希望让生产环境的部署更加高效，则应该尽可能让开发环境和生产环境保持一致。这时你应该考虑直接在本地使用 MySQL 或 PostgreSQL 等性能更高的 DBMS ，然后设置迁移环境。

## 5.8 数据库进阶实践

1. 本节将介绍一些使用 SQLAlchemy 的进阶技巧，用于简化操作数据库的过程。

### 5.8.1　级联操作

1. Cascade 意为级联操作，就是在操作一个对象的同时，对相关的对象也执行某些操作。我们通过一个 Post 模型和 Comment 模型来演示级联操作，分别表示文章(帖子)和评论，两者为一对多关系：

   ```python
   class Post(db.Model):
       id = db.Column(db.Integer, primary_key=True)
       title = db.Column(db.String(50), unique=True)
       body = db.Column(db.Text)
       comments = db.relationship("Comment", back_populates="post")

   class Comment(db.Model):
      id = db.Column(db.Integer, primary_key=True)
      body = db.Column(db.Text)
      post_id = db.Column(db.Integer, db.ForeignKey("post.id"))
      post = db.relationship("Post", back_populates="comments")
   ```

2. 级联行为通过关系函数 relationship() 的 cascade 参数设置。我们希望在操作 Post 对象时，处于附属地位的 Comment 对象也被相应执行某些操作，这时应该在 Post 类的关系函数中定义级联参数。设置了 cascade 参数的一侧将被视为父对象，相关的对象则被视为子对象。

3. cascade 通常使用多个组合值，级联值之间使用逗号分隔，比如：

   ```python
   class Post(db.Model):
       ...
       comments = relationship('Comment', cascade='save-update, merge, delete')
   ```

4. 常用的配置组合如下所示：

   - save-update、merge(默认值)
   - save-update、merge、delete
   - all
   - all、delete-orphan

5. 当没有设置 cascade 参数时，会使用默认值 save-update、merge。上面的 all 等同于除了 delete-orphan 以外所有可用值的组合，即 save、update、merge、refresh-expire、expunge、delete 。

#### 5.8.1.1 save-update

1. save-update 是默认的级联行为，当 cascade 参数设为 save-update 时，如果使用 db.session.add() 方法将 Post 对象添加到数据库会话时，那么与 Post 相关联的 Comment 对象也将被添加到数据库会话。我们首先创建一个 Post 对象和两个 Comment 对象：

   ```python
   >>> post1 = Post()
   >>> comment1 =Comment()
   >>> comment2 =Comment()
   ```

2. 将 post1 添加到数据库会话后，只有 post1 在数据库会话中：

   ```python
   >>> db.session.add(post1)
   >>> post1 in db.session
   True
   >>> comment1 in db.session
   False
   >>> comment2 in db.session
   False
   ```

3. 如果我们让 post1 与这两个 Comment 对象建立关系，那么这两个 Comment 对象也会自动被添加到数据库会话中：

   ```python
   >>> post1.comments.append(comment1)
   >>> post1.comments.append(comment2)
   >>> comment1 in db.session
   True
   >>> comment2 in db.session
   True
   ```

4. 当调用 db.session.commit() 提交数据库会话时，这三个对象都会被提交到数据库中。

#### 5.8.1.2 delete

1. 如果某个 Post 对象被删除，那么按照默认的行为，该 Post 对象相关联的所有 Comment 对象都将与这个 Post 对象取消关联，外键字段的值会被清空。如果 Post 类的关系函数中 cascade 参数设为 delete 时，这些相关的 Comment 会在关联的 Post 对象删除时被一并删除。当需要设置 delete 级联时，我们会将级联值设为 all 或 save-update、merge、delete，比如：

   ```python
   class Post(db.Model):
       ...
       comments = relationship('Comment', cascade='all')
   ```

2. 我们先创建一个文章对象 post2 和两个评论对象 comment3 和 comment4 ，并将这两个评论对象与文章对象建立关系，将它们添加到数据库会话并提交：

   ```python
   >>> post2 = Post()
   >>> comment3 = Comment()
   >>> comment4 = Comment()
   >>> post2.comments.append(comment3)
   >>> post2.comments.append(comment4)
   >>> db.session.add(post2)
   >>> db.session.commit()
   ```

3. 现在共有两条 Post 记录和四条 Comment 记录：

   ```python
   >>> Post.query.all()
   [<Post 1>, <Post 2>]
   >>> Comment.query.all()
   [<Comment 1>, <Comment 2>, <Comment 3>, <Comment 4>]
   ```

4. 如果删除文章对象 post2 ，那么对应的两个评论对象也会一并被删除：

   ```python
   >>> post2 = Post.query.get(2)
   >>> db.session.delete(post2)
   >>> db.session.commit()
   >>> Post.query.all()
   [<Post 1>]
   >>> Comment.query.all()
   [<Comment 1>, <Comment 2>]
   ```

#### 5.8.1.3 delete-orphan

1. 这个模式是基于 delete 级联的，必须和 delete 级联一起使用，通常会设为 all、delete-orphan，因为 all 包含 delete 。因此当 cascade 参数设为 delete-orphan 时，它首先包含 delete 级联的行为：当某个 Post 对象被删除时，所有相关的 Comment 对象都将被删除(delete 级联)。

2. 除此之外，当某个 Post 对象(父对象)与某个 Comment 对象(子对象)解除关系时，也会删除该 Comment 对象，这个解除关系的对象被称为孤立对象(orphan object)。现在 comments 属性中的级联值为 all、delete-orphan，如下所示：

   ```python
   class Post(db.Model):
       ...
       comments = relationship('Comment', cascade='all, delete-orphan')
   ```

3. 我们先创建一个文章对象 post3 和两个评论对象 comment5 和 comment6，并将这两个评论对象与文章对象建立关系，将它们添加到数据库会话并提交：

   ```python
   >>> post3 = Post()
   >>> comment5 = Comment()
   >>> comment6 = Comment()
   >>> post3.comments.append(comment5)
   >>> post3.comments.append(comment6)
   >>> db.session.add(post3)
   >>> db.session.commit()
   ```

4. 现在数据库中共有两条文章记录和四条评论记录：

   ```python
   >>> Post.query.all()
   [<Post 1>, <Post 3>]
   >>> Comment.query.all()
   [<Comment 1>, <Comment 2>, <Comment 5>, <Comment 6>]
   ```

5. 下面我们将 comment5 和 comment6 与 post3 解除关系并提交数据库会话：

   ```python
   >>> post3.comments.remove(comment5)
   >>> post3.comments.remove(comment6)
   >>> db.session.commit()
   ```

6. 默认情况下，相关评论对象的外键会被设为空值。因为我们设置了 delete-orphan 级联，所以现在你会发现解除关系的两条评论记录都被删除了：

   ```python
   >>> Comment.query.all()
   [<Comment 1>, <Comment 2>]
   ```

7. delete 和 delete-orphan 通常会在一对多关系模式中，而且多这一侧的对象附属于一这一侧的对象时使用。尤其是如果一这一侧的父对象不存在了，那么多这一侧的子对象不再有意义的情况。

8. 比如，文章和评论的关系就是一个典型的示例。当文章被删除了，那么评论也就没必要再留存。在这种情况下，如果不使用级联操作，那么我们就需要手动迭代关系另一侧的所有评论对象，然后一一进行删除操作。

9. 对于这两个级联选项，如果你不会通过列表语义对集合关系属性调用 remove() 方法等方式来操作关系，那么使用 delete 级联即可。

10. 虽然级联操作方便，但是容易带来安全隐患，因此要谨慎使用。默认值能够满足大部分情况，所以最好仅在需要的时候才修改它。

11. 在 SQLAlchemy 中，级联的行为和配置选项等最初衍生自另一个 ORM——Hibernate ORM 。

### 5.8.2　事件监听

1. 在 Flask 中，我们可以使用 Flask 提供的多个装饰器注册请求回调函数，它们会在特定的请求处理环节被执行。类似的，SQLAlchemy 也提供了一个 listen_for() 装饰器，它可以用来注册事件回调函数。

2. listen_for() 装饰器主要接收两个参数，target 表示监听的对象，这个对象可以是模型类、类实例或类属性等。identifier 参数表示被监听事件的标识符，比如，用于监听属性的事件标识符有 set、append、 remove、init_scalar、init_collection 等。

3. 为了演示事件监听，我们创建了一个 Draft 模型类表示草稿，其中包含 body 字段和 edit_time 字段，分别存储草稿正文和被修改的次数，其中 edit_time 字段的默认值为 0 ，如下所示：

   ```python
   class Draft(db.Model):
       id = db.Column(db.Integer, primary_key=True)
       body = db.Column(db.Text)
       edit_time = db.Column(db.Integer, default=0)

   ```

4. 通过注册事件监听函数，我们可以实现在 body 列修改时，自动叠加表示被修改次数的 edit_time 字段。

5. 在 SQLAlchemy 中，每个事件都会有一个对应的事件方法，不同的事件方法支持不同的参数。被注册的监听函数需要接收对应事件方法的所有参数，所以具体的监听函数用法因使用的事件而异。设置某个字段值将触发 set 事件，如下代码是我们为 set 事件编写的事件监听函数。

   <center><b>database/app.py：set 事件监听函数</b></center>

   ```python
   @db.event.listens_for(Draft.body, "set")
   def increment_edit_time(target, value, oldvalue, initiator):
       if target.edit_time is not None:
           target.edit_time += 1

   ```

6. 我们在 listen_for() 装饰器中分别传入 Draft.body 和 set 作为 targe 和 identifier 参数的值。监听函数接收所有 set() 事件方法接收的参数，其中的 target 参数表示触发事件的模型类实例，使用 target.edit_time 即可获取我们需要叠加的字段。其他的参数也需要照常写出，虽然这里没有用到。value 表示被设置的值，oldvalue 表示被取代的旧值。

7. 当 set 事件发生在目标对象 Draft.body 上时，这个监听函数就会被执行，从而自动叠加 Draft.edit_time 列的值，如下所示：

   ```python
   >>> draft = Draft(body='init')
   >>> db.session.add(draft)
   >>> db.session.commit()
   >>> draft.edit_time
   0
   >>> draft.body = 'edited'
   >>> draft.edit_time
   1
   >>> draft.body = 'edited again'
   >>> draft.edit_time
   2
   >>> draft.body = 'edited again again'
   >>> draft.edit_time
   3
   >>> db.session.commit()
   ```

8. 除了这种传统的参数接收方式，即接收所有事件方法接收的参数，还有一种更简单的方法。

9. 通过在 listen_for() 装饰器中将关键字参数 name 设为 True ，可以在监听函数中接收 **kwargs 作为参数(可变长关键字参数)，即 named argument 。然后在函数中可以使用参数名作为键来从** kwargs 字典获取对应的参数值：

   ```python
   @db.event.listens_for(Draft.body, 'set', named=True)
   def increment_edit_time(**kwargs):
       if kwargs['target'].edit_time is not None:
           kwargs['target'].edit_time += 1
   ```

10. SQLAlchemy 作为 SQL 工具集本身包含两大主要组件：SQLAlchemy ORM 和 SQLAlchemy Core 。前者实现了我们前面介绍的 ORM 功能，后者实现了数据库接口等核心功能，这两类组件都提供了大量的监听事件，几乎覆盖整个 SQLAlchemy 使用的生命周期。请访问下面的链接查看可用的事件列表以及具体的事件方法使用介绍：

    - [SQLAlchemy Core 事件](<http://docs.sqlalchemy.org/en/latest/core/events.html>)
    - [SQLAlchemy ORM 事件](<http://docs.sqlalchemy.org/en/latest/orm/events.html>)

11. 除了使用 listen_for 装饰器，我们还可以直接使用它内部调用的 listen() 函数注册事件监听函数时，第三个参数传入被注册的函数对象，比如 db.event.listen(SomeClass，'load'，my_load_listener)。

## 5.9 本章小结

1. 这一章的内容可以让你简单了解在Flask应用中使用数据库的方法，但数据库的内容还有很多，这里只是一个简单的介绍。
2. 如果你想了解更多具体细节，SQLAlchemy 提供的[入门教程](<http://docs.sqlalchemy.org/en/latest/orm/tutorial.html>)是个起步的好地方。另外，如果你还不熟悉 SQL ，那么有必要去学习一下，掌握 SQL 可以让你更高效地使用 ORM 。
